{
  "id": "9ee2848b-2491-426e-ae4c-de6aaab5d9fd",
  "prefix": "mvpOH_DatabaseIntegrityCheck",
  "description": "DatabaseIntegrityCheck (By Ola Hallengren)",
  "body": "USE [master]\r\nGO\r\n\r\n/****** Object:  StoredProcedure [dbo].[DatabaseIntegrityCheck] ******/\r\nIF OBJECT_ID('[dbo].[DatabaseIntegrityCheck]', 'P') IS NOT NULL\r\n\tDROP PROCEDURE [dbo].[DatabaseIntegrityCheck];\r\nGO\r\n\r\n/****** Object:  StoredProcedure [dbo].[DatabaseIntegrityCheck] ******/\r\nSET ANSI_NULLS ON\r\nGO\r\n\r\nSET QUOTED_IDENTIFIER ON\r\nGO\r\n\r\nCREATE PROCEDURE [dbo].[DatabaseIntegrityCheck]\r\n\r\n@Databases NVARCHAR(MAX) = NULL,\r\n@CheckCommands NVARCHAR(MAX) = 'CHECKDB',\r\n@PhysicalOnly NVARCHAR(MAX) = 'N',\r\n@DataPurity NVARCHAR(MAX) = 'N',\r\n@NoIndex NVARCHAR(MAX) = 'N',\r\n@ExtendedLogicalChecks NVARCHAR(MAX) = 'N',\r\n@TabLock NVARCHAR(MAX) = 'N',\r\n@FileGroups NVARCHAR(MAX) = NULL,\r\n@Objects NVARCHAR(MAX) = NULL,\r\n@MaxDOP INT = NULL,\r\n@AvailabilityGroups NVARCHAR(MAX) = NULL,\r\n@AvailabilityGroupReplicas NVARCHAR(MAX) = 'ALL',\r\n@Updateability NVARCHAR(MAX) = 'ALL',\r\n@TimeLimit INT = NULL,\r\n@LockTimeout INT = NULL,\r\n@LockMessageSeverity INT = 16,\r\n@StringDelimiter NVARCHAR(MAX) = ',',\r\n@DatabaseOrder NVARCHAR(MAX) = NULL,\r\n@DatabasesInParallel NVARCHAR(MAX) = 'N',\r\n@LogToTable NVARCHAR(MAX) = 'N',\r\n@Execute NVARCHAR(MAX) = 'Y'\r\n\r\nAS\r\n\r\nBEGIN\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Source:  https://ola.hallengren.com                                                        //--\r\n  --// License: https://ola.hallengren.com/license.html                                           //--\r\n  --// GitHub:  https://github.com/olahallengren/sql-server-maintenance-solution                  //--\r\n  --// Version: 2020-12-31 18:58:56                                                               //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET NOCOUNT ON\r\n\r\n  DECLARE @StartMessage nvarchar(max)\r\n  DECLARE @EndMessage nvarchar(max)\r\n  DECLARE @DatabaseMessage nvarchar(max)\r\n  DECLARE @ErrorMessage nvarchar(max)\r\n  DECLARE @Severity int\r\n\r\n  DECLARE @StartTime datetime2 = SYSDATETIME()\r\n  DECLARE @SchemaName nvarchar(max) = OBJECT_SCHEMA_NAME(@@PROCID)\r\n  DECLARE @ObjectName nvarchar(max) = OBJECT_NAME(@@PROCID)\r\n  DECLARE @VersionTimestamp nvarchar(max) = SUBSTRING(OBJECT_DEFINITION(@@PROCID),CHARINDEX('--// Version: ',OBJECT_DEFINITION(@@PROCID)) + LEN('--// Version: ') + 1, 19)\r\n  DECLARE @Parameters nvarchar(max)\r\n\r\n  DECLARE @HostPlatform nvarchar(max)\r\n\r\n  DECLARE @QueueID int\r\n  DECLARE @QueueStartTime datetime2\r\n\r\n  DECLARE @CurrentDBID int\r\n  DECLARE @CurrentDatabaseName nvarchar(max)\r\n\r\n  DECLARE @CurrentDatabase_sp_executesql nvarchar(max)\r\n\r\n  DECLARE @CurrentUserAccess nvarchar(max)\r\n  DECLARE @CurrentIsReadOnly bit\r\n  DECLARE @CurrentDatabaseState nvarchar(max)\r\n  DECLARE @CurrentInStandby bit\r\n  DECLARE @CurrentRecoveryModel nvarchar(max)\r\n\r\n  DECLARE @CurrentIsDatabaseAccessible bit\r\n  DECLARE @CurrentReplicaID uniqueidentifier\r\n  DECLARE @CurrentAvailabilityGroupID uniqueidentifier\r\n  DECLARE @CurrentAvailabilityGroup nvarchar(max)\r\n  DECLARE @CurrentAvailabilityGroupRole nvarchar(max)\r\n  DECLARE @CurrentAvailabilityGroupBackupPreference nvarchar(max)\r\n  DECLARE @CurrentSecondaryRoleAllowConnections nvarchar(max)\r\n  DECLARE @CurrentIsPreferredBackupReplica bit\r\n  DECLARE @CurrentDatabaseMirroringRole nvarchar(max)\r\n\r\n  DECLARE @CurrentFGID int\r\n  DECLARE @CurrentFileGroupID int\r\n  DECLARE @CurrentFileGroupName nvarchar(max)\r\n  DECLARE @CurrentFileGroupExists bit\r\n\r\n  DECLARE @CurrentOID int\r\n  DECLARE @CurrentSchemaID int\r\n  DECLARE @CurrentSchemaName nvarchar(max)\r\n  DECLARE @CurrentObjectID int\r\n  DECLARE @CurrentObjectName nvarchar(max)\r\n  DECLARE @CurrentObjectType nvarchar(max)\r\n  DECLARE @CurrentObjectExists bit\r\n\r\n  DECLARE @CurrentDatabaseContext nvarchar(max)\r\n  DECLARE @CurrentCommand nvarchar(max)\r\n  DECLARE @CurrentCommandOutput int\r\n  DECLARE @CurrentCommandType nvarchar(max)\r\n\r\n  DECLARE @Errors TABLE (ID int IDENTITY PRIMARY KEY,\r\n                         [Message] nvarchar(max) NOT NULL,\r\n                         Severity int NOT NULL,\r\n                         [State] int)\r\n\r\n  DECLARE @CurrentMessage nvarchar(max)\r\n  DECLARE @CurrentSeverity int\r\n  DECLARE @CurrentState int\r\n\r\n  DECLARE @tmpDatabases TABLE (ID int IDENTITY,\r\n                               DatabaseName nvarchar(max),\r\n                               DatabaseType nvarchar(max),\r\n                               AvailabilityGroup bit,\r\n                               [Snapshot] bit,\r\n                               StartPosition int,\r\n                               LastCommandTime datetime2,\r\n                               DatabaseSize bigint,\r\n                               LastGoodCheckDbTime datetime2,\r\n                               [Order] int,\r\n                               Selected bit,\r\n                               Completed bit,\r\n                               PRIMARY KEY(Selected, Completed, [Order], ID))\r\n\r\n  DECLARE @tmpAvailabilityGroups TABLE (ID int IDENTITY PRIMARY KEY,\r\n                                        AvailabilityGroupName nvarchar(max),\r\n                                        StartPosition int,\r\n                                        Selected bit)\r\n\r\n  DECLARE @tmpDatabasesAvailabilityGroups TABLE (DatabaseName nvarchar(max),\r\n                                                 AvailabilityGroupName nvarchar(max))\r\n\r\n  DECLARE @tmpFileGroups TABLE (ID int IDENTITY,\r\n                                FileGroupID int,\r\n                                FileGroupName nvarchar(max),\r\n                                StartPosition int,\r\n                                [Order] int,\r\n                                Selected bit,\r\n                                Completed bit,\r\n                                PRIMARY KEY(Selected, Completed, [Order], ID))\r\n\r\n  DECLARE @tmpObjects TABLE (ID int IDENTITY,\r\n                             SchemaID int,\r\n                             SchemaName nvarchar(max),\r\n                             ObjectID int,\r\n                             ObjectName nvarchar(max),\r\n                             ObjectType nvarchar(max),\r\n                             StartPosition int,\r\n                             [Order] int,\r\n                             Selected bit,\r\n                             Completed bit,\r\n                             PRIMARY KEY(Selected, Completed, [Order], ID))\r\n\r\n  DECLARE @SelectedDatabases TABLE (DatabaseName nvarchar(max),\r\n                                    DatabaseType nvarchar(max),\r\n                                    AvailabilityGroup nvarchar(max),\r\n                                    StartPosition int,\r\n                                    Selected bit)\r\n\r\n  DECLARE @SelectedAvailabilityGroups TABLE (AvailabilityGroupName nvarchar(max),\r\n                                             StartPosition int,\r\n                                             Selected bit)\r\n\r\n  DECLARE @SelectedFileGroups TABLE (DatabaseName nvarchar(max),\r\n                                     FileGroupName nvarchar(max),\r\n                                     StartPosition int,\r\n                                     Selected bit)\r\n\r\n  DECLARE @SelectedObjects TABLE (DatabaseName nvarchar(max),\r\n                                  SchemaName nvarchar(max),\r\n                                  ObjectName nvarchar(max),\r\n                                  StartPosition int,\r\n                                  Selected bit)\r\n\r\n  DECLARE @SelectedCheckCommands TABLE (CheckCommand nvarchar(max))\r\n\r\n  DECLARE @Error int = 0\r\n  DECLARE @ReturnCode int = 0\r\n\r\n  DECLARE @EmptyLine nvarchar(max) = CHAR(9)\r\n\r\n  DECLARE @Version numeric(18,10) = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))\r\n\r\n  IF @Version >= 14\r\n  BEGIN\r\n    SELECT @HostPlatform = host_platform\r\n    FROM sys.dm_os_host_info\r\n  END\r\n  ELSE\r\n  BEGIN\r\n    SET @HostPlatform = 'Windows'\r\n  END\r\n\r\n  DECLARE @AmazonRDS bit = CASE WHEN DB_ID('rdsadmin') IS NOT NULL AND SUSER_SNAME(0x01) = 'rdsa' THEN 1 ELSE 0 END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Log initial information                                                                    //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET @Parameters = '@Databases = ' + ISNULL('''' + REPLACE(@Databases,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @CheckCommands = ' + ISNULL('''' + REPLACE(@CheckCommands,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @PhysicalOnly = ' + ISNULL('''' + REPLACE(@PhysicalOnly,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @DataPurity = ' + ISNULL('''' + REPLACE(@DataPurity,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @NoIndex = ' + ISNULL('''' + REPLACE(@NoIndex,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @ExtendedLogicalChecks = ' + ISNULL('''' + REPLACE(@ExtendedLogicalChecks,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @TabLock = ' + ISNULL('''' + REPLACE(@TabLock,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @FileGroups = ' + ISNULL('''' + REPLACE(@FileGroups,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @Objects = ' + ISNULL('''' + REPLACE(@Objects,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @MaxDOP = ' + ISNULL(CAST(@MaxDOP AS nvarchar),'NULL')\r\n  SET @Parameters += ', @AvailabilityGroups = ' + ISNULL('''' + REPLACE(@AvailabilityGroups,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @AvailabilityGroupReplicas = ' + ISNULL('''' + REPLACE(@AvailabilityGroupReplicas,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @Updateability = ' + ISNULL('''' + REPLACE(@Updateability,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @TimeLimit = ' + ISNULL(CAST(@TimeLimit AS nvarchar),'NULL')\r\n  SET @Parameters += ', @LockTimeout = ' + ISNULL(CAST(@LockTimeout AS nvarchar),'NULL')\r\n  SET @Parameters += ', @LockMessageSeverity = ' + ISNULL(CAST(@LockMessageSeverity AS nvarchar),'NULL')\r\n  SET @Parameters += ', @StringDelimiter = ' + ISNULL('''' + REPLACE(@StringDelimiter,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @DatabaseOrder = ' + ISNULL('''' + REPLACE(@DatabaseOrder,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @DatabasesInParallel = ' + ISNULL('''' + REPLACE(@DatabasesInParallel,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @LogToTable = ' + ISNULL('''' + REPLACE(@LogToTable,'''','''''') + '''','NULL')\r\n  SET @Parameters += ', @Execute = ' + ISNULL('''' + REPLACE(@Execute,'''','''''') + '''','NULL')\r\n\r\n  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,@StartTime,120)\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Server: ' + CAST(SERVERPROPERTY('ServerName') AS nvarchar(max))\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Version: ' + CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Edition: ' + CAST(SERVERPROPERTY('Edition') AS nvarchar(max))\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Platform: ' + @HostPlatform\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Procedure: ' + QUOTENAME(DB_NAME(DB_ID())) + '.' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@ObjectName)\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Parameters: ' + @Parameters\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Version: ' + @VersionTimestamp\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  SET @StartMessage = 'Source: https://ola.hallengren.com'\r\n  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT\r\n\r\n  RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Check core requirements                                                                    //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF NOT (SELECT [compatibility_level] FROM sys.databases WHERE database_id = DB_ID()) >= 90\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT  'The database ' + QUOTENAME(DB_NAME(DB_ID())) + ' has to be in compatibility level 90 or higher.', 16, 1\r\n  END\r\n\r\n  IF NOT (SELECT uses_ansi_nulls FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'ANSI_NULLS has to be set to ON for the stored procedure.', 16, 1\r\n  END\r\n\r\n  IF NOT (SELECT uses_quoted_identifier FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'QUOTED_IDENTIFIER has to be set to ON for the stored procedure.', 16, 1\r\n  END\r\n\r\n  IF NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The stored procedure CommandExecute is missing. Download https://ola.hallengren.com/scripts/CommandExecute.sql.', 16, 1\r\n  END\r\n\r\n  IF EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute' AND OBJECT_DEFINITION(objects.[object_id]) NOT LIKE '%@DatabaseContext%')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The stored procedure CommandExecute needs to be updated. Download https://ola.hallengren.com/scripts/CommandExecute.sql.', 16, 1\r\n  END\r\n\r\n  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The table CommandLog is missing. Download https://ola.hallengren.com/scripts/CommandLog.sql.', 16, 1\r\n  END\r\n\r\n  IF @DatabasesInParallel = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'Queue')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The table Queue is missing. Download https://ola.hallengren.com/scripts/Queue.sql.', 16, 1\r\n  END\r\n\r\n  IF @DatabasesInParallel = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'QueueDatabase')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The table QueueDatabase is missing. Download https://ola.hallengren.com/scripts/QueueDatabase.sql.', 16, 1\r\n  END\r\n\r\n  IF @@TRANCOUNT <> 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The transaction count is not 0.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Select databases                                                                           //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET @Databases = REPLACE(@Databases, CHAR(10), '')\r\n  SET @Databases = REPLACE(@Databases, CHAR(13), '')\r\n\r\n  WHILE CHARINDEX(@StringDelimiter + ' ', @Databases) > 0 SET @Databases = REPLACE(@Databases, @StringDelimiter + ' ', @StringDelimiter)\r\n  WHILE CHARINDEX(' ' + @StringDelimiter, @Databases) > 0 SET @Databases = REPLACE(@Databases, ' ' + @StringDelimiter, @StringDelimiter)\r\n\r\n  SET @Databases = LTRIM(RTRIM(@Databases));\r\n\r\n  WITH Databases1 (StartPosition, EndPosition, DatabaseItem) AS\r\n  (\r\n  SELECT 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, 1), 0), LEN(@Databases) + 1) AS EndPosition,\r\n         SUBSTRING(@Databases, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, 1), 0), LEN(@Databases) + 1) - 1) AS DatabaseItem\r\n  WHERE @Databases IS NOT NULL\r\n  UNION ALL\r\n  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) AS EndPosition,\r\n         SUBSTRING(@Databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) - EndPosition - 1) AS DatabaseItem\r\n  FROM Databases1\r\n  WHERE EndPosition < LEN(@Databases) + 1\r\n  ),\r\n  Databases2 (DatabaseItem, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN DatabaseItem LIKE '-%' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem,\r\n         StartPosition,\r\n         CASE WHEN DatabaseItem LIKE '-%' THEN 0 ELSE 1 END AS Selected\r\n  FROM Databases1\r\n  ),\r\n  Databases3 (DatabaseItem, DatabaseType, AvailabilityGroup, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN DatabaseItem IN('ALL_DATABASES','SYSTEM_DATABASES','USER_DATABASES','AVAILABILITY_GROUP_DATABASES') THEN '%' ELSE DatabaseItem END AS DatabaseItem,\r\n         CASE WHEN DatabaseItem = 'SYSTEM_DATABASES' THEN 'S' WHEN DatabaseItem = 'USER_DATABASES' THEN 'U' ELSE NULL END AS DatabaseType,\r\n         CASE WHEN DatabaseItem = 'AVAILABILITY_GROUP_DATABASES' THEN 1 ELSE NULL END AvailabilityGroup,\r\n         StartPosition,\r\n         Selected\r\n  FROM Databases2\r\n  ),\r\n  Databases4 (DatabaseName, DatabaseType, AvailabilityGroup, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN LEFT(DatabaseItem,1) = '[' AND RIGHT(DatabaseItem,1) = ']' THEN PARSENAME(DatabaseItem,1) ELSE DatabaseItem END AS DatabaseItem,\r\n         DatabaseType,\r\n         AvailabilityGroup,\r\n         StartPosition,\r\n         Selected\r\n  FROM Databases3\r\n  )\r\n  INSERT INTO @SelectedDatabases (DatabaseName, DatabaseType, AvailabilityGroup, StartPosition, Selected)\r\n  SELECT DatabaseName,\r\n         DatabaseType,\r\n         AvailabilityGroup,\r\n         StartPosition,\r\n         Selected\r\n  FROM Databases4\r\n  OPTION (MAXRECURSION 0)\r\n\r\n  IF @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1\r\n  BEGIN\r\n    INSERT INTO @tmpAvailabilityGroups (AvailabilityGroupName, Selected)\r\n    SELECT name AS AvailabilityGroupName,\r\n           0 AS Selected\r\n    FROM sys.availability_groups\r\n\r\n    INSERT INTO @tmpDatabasesAvailabilityGroups (DatabaseName, AvailabilityGroupName)\r\n    SELECT databases.name,\r\n           availability_groups.name\r\n    FROM sys.databases databases\r\n    INNER JOIN sys.availability_replicas availability_replicas ON databases.replica_id = availability_replicas.replica_id\r\n    INNER JOIN sys.availability_groups availability_groups ON availability_replicas.group_id = availability_groups.group_id\r\n  END\r\n\r\n  INSERT INTO @tmpDatabases (DatabaseName, DatabaseType, AvailabilityGroup, [Snapshot], [Order], Selected, Completed)\r\n  SELECT [name] AS DatabaseName,\r\n         CASE WHEN name IN('master','msdb','model') OR is_distributor = 1 THEN 'S' ELSE 'U' END AS DatabaseType,\r\n         NULL AS AvailabilityGroup,\r\n         CASE WHEN source_database_id IS NOT NULL THEN 1 ELSE 0 END AS [Snapshot],\r\n         0 AS [Order],\r\n         0 AS Selected,\r\n         0 AS Completed\r\n  FROM sys.databases\r\n  ORDER BY [name] ASC\r\n\r\n  UPDATE tmpDatabases\r\n  SET AvailabilityGroup = CASE WHEN EXISTS (SELECT * FROM @tmpDatabasesAvailabilityGroups WHERE DatabaseName = tmpDatabases.DatabaseName) THEN 1 ELSE 0 END\r\n  FROM @tmpDatabases tmpDatabases\r\n\r\n  UPDATE tmpDatabases\r\n  SET tmpDatabases.Selected = SelectedDatabases.Selected\r\n  FROM @tmpDatabases tmpDatabases\r\n  INNER JOIN @SelectedDatabases SelectedDatabases\r\n  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')\r\n  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)\r\n  AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)\r\n  AND NOT ((tmpDatabases.DatabaseName = 'tempdb' OR tmpDatabases.[Snapshot] = 1) AND tmpDatabases.DatabaseName <> SelectedDatabases.DatabaseName)\r\n  WHERE SelectedDatabases.Selected = 1\r\n\r\n  UPDATE tmpDatabases\r\n  SET tmpDatabases.Selected = SelectedDatabases.Selected\r\n  FROM @tmpDatabases tmpDatabases\r\n  INNER JOIN @SelectedDatabases SelectedDatabases\r\n  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')\r\n  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)\r\n  AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)\r\n  AND NOT ((tmpDatabases.DatabaseName = 'tempdb' OR tmpDatabases.[Snapshot] = 1) AND tmpDatabases.DatabaseName <> SelectedDatabases.DatabaseName)\r\n  WHERE SelectedDatabases.Selected = 0\r\n\r\n  UPDATE tmpDatabases\r\n  SET tmpDatabases.StartPosition = SelectedDatabases2.StartPosition\r\n  FROM @tmpDatabases tmpDatabases\r\n  INNER JOIN (SELECT tmpDatabases.DatabaseName, MIN(SelectedDatabases.StartPosition) AS StartPosition\r\n              FROM @tmpDatabases tmpDatabases\r\n              INNER JOIN @SelectedDatabases SelectedDatabases\r\n              ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')\r\n              AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)\r\n              AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)\r\n              WHERE SelectedDatabases.Selected = 1\r\n              GROUP BY tmpDatabases.DatabaseName) SelectedDatabases2\r\n  ON tmpDatabases.DatabaseName = SelectedDatabases2.DatabaseName\r\n\r\n  IF @Databases IS NOT NULL AND (NOT EXISTS(SELECT * FROM @SelectedDatabases) OR EXISTS(SELECT * FROM @SelectedDatabases WHERE DatabaseName IS NULL OR DatabaseName = ''))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @Databases is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Select availability groups                                                                 //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @AvailabilityGroups IS NOT NULL AND @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1\r\n  BEGIN\r\n\r\n    SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, CHAR(10), '')\r\n    SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, CHAR(13), '')\r\n\r\n    WHILE CHARINDEX(@StringDelimiter + ' ', @AvailabilityGroups) > 0 SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, @StringDelimiter + ' ', @StringDelimiter)\r\n    WHILE CHARINDEX(' ' + @StringDelimiter, @AvailabilityGroups) > 0 SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, ' ' + @StringDelimiter, @StringDelimiter)\r\n\r\n    SET @AvailabilityGroups = LTRIM(RTRIM(@AvailabilityGroups));\r\n\r\n    WITH AvailabilityGroups1 (StartPosition, EndPosition, AvailabilityGroupItem) AS\r\n    (\r\n    SELECT 1 AS StartPosition,\r\n           ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, 1), 0), LEN(@AvailabilityGroups) + 1) AS EndPosition,\r\n           SUBSTRING(@AvailabilityGroups, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, 1), 0), LEN(@AvailabilityGroups) + 1) - 1) AS AvailabilityGroupItem\r\n    WHERE @AvailabilityGroups IS NOT NULL\r\n    UNION ALL\r\n    SELECT CAST(EndPosition AS int) + 1 AS StartPosition,\r\n           ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, EndPosition + 1), 0), LEN(@AvailabilityGroups) + 1) AS EndPosition,\r\n           SUBSTRING(@AvailabilityGroups, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, EndPosition + 1), 0), LEN(@AvailabilityGroups) + 1) - EndPosition - 1) AS AvailabilityGroupItem\r\n    FROM AvailabilityGroups1\r\n    WHERE EndPosition < LEN(@AvailabilityGroups) + 1\r\n    ),\r\n    AvailabilityGroups2 (AvailabilityGroupItem, StartPosition, Selected) AS\r\n    (\r\n    SELECT CASE WHEN AvailabilityGroupItem LIKE '-%' THEN RIGHT(AvailabilityGroupItem,LEN(AvailabilityGroupItem) - 1) ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,\r\n           StartPosition,\r\n           CASE WHEN AvailabilityGroupItem LIKE '-%' THEN 0 ELSE 1 END AS Selected\r\n    FROM AvailabilityGroups1\r\n    ),\r\n    AvailabilityGroups3 (AvailabilityGroupItem, StartPosition, Selected) AS\r\n    (\r\n    SELECT CASE WHEN AvailabilityGroupItem = 'ALL_AVAILABILITY_GROUPS' THEN '%' ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,\r\n           StartPosition,\r\n           Selected\r\n    FROM AvailabilityGroups2\r\n    ),\r\n    AvailabilityGroups4 (AvailabilityGroupName, StartPosition, Selected) AS\r\n    (\r\n    SELECT CASE WHEN LEFT(AvailabilityGroupItem,1) = '[' AND RIGHT(AvailabilityGroupItem,1) = ']' THEN PARSENAME(AvailabilityGroupItem,1) ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,\r\n           StartPosition,\r\n           Selected\r\n    FROM AvailabilityGroups3\r\n    )\r\n    INSERT INTO @SelectedAvailabilityGroups (AvailabilityGroupName, StartPosition, Selected)\r\n    SELECT AvailabilityGroupName, StartPosition, Selected\r\n    FROM AvailabilityGroups4\r\n    OPTION (MAXRECURSION 0)\r\n\r\n    UPDATE tmpAvailabilityGroups\r\n    SET tmpAvailabilityGroups.Selected = SelectedAvailabilityGroups.Selected\r\n    FROM @tmpAvailabilityGroups tmpAvailabilityGroups\r\n    INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups\r\n    ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,'_','[_]')\r\n    WHERE SelectedAvailabilityGroups.Selected = 1\r\n\r\n    UPDATE tmpAvailabilityGroups\r\n    SET tmpAvailabilityGroups.Selected = SelectedAvailabilityGroups.Selected\r\n    FROM @tmpAvailabilityGroups tmpAvailabilityGroups\r\n    INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups\r\n    ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,'_','[_]')\r\n    WHERE SelectedAvailabilityGroups.Selected = 0\r\n\r\n    UPDATE tmpAvailabilityGroups\r\n    SET tmpAvailabilityGroups.StartPosition = SelectedAvailabilityGroups2.StartPosition\r\n    FROM @tmpAvailabilityGroups tmpAvailabilityGroups\r\n    INNER JOIN (SELECT tmpAvailabilityGroups.AvailabilityGroupName, MIN(SelectedAvailabilityGroups.StartPosition) AS StartPosition\r\n                FROM @tmpAvailabilityGroups tmpAvailabilityGroups\r\n                INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups\r\n                ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,'_','[_]')\r\n                WHERE SelectedAvailabilityGroups.Selected = 1\r\n                GROUP BY tmpAvailabilityGroups.AvailabilityGroupName) SelectedAvailabilityGroups2\r\n    ON tmpAvailabilityGroups.AvailabilityGroupName = SelectedAvailabilityGroups2.AvailabilityGroupName\r\n\r\n    UPDATE tmpDatabases\r\n    SET tmpDatabases.StartPosition = tmpAvailabilityGroups.StartPosition,\r\n        tmpDatabases.Selected = 1\r\n    FROM @tmpDatabases tmpDatabases\r\n    INNER JOIN @tmpDatabasesAvailabilityGroups tmpDatabasesAvailabilityGroups ON tmpDatabases.DatabaseName = tmpDatabasesAvailabilityGroups.DatabaseName\r\n    INNER JOIN @tmpAvailabilityGroups tmpAvailabilityGroups ON tmpDatabasesAvailabilityGroups.AvailabilityGroupName = tmpAvailabilityGroups.AvailabilityGroupName\r\n    WHERE tmpAvailabilityGroups.Selected = 1\r\n\r\n  END\r\n\r\n  IF @AvailabilityGroups IS NOT NULL AND (NOT EXISTS(SELECT * FROM @SelectedAvailabilityGroups) OR EXISTS(SELECT * FROM @SelectedAvailabilityGroups WHERE AvailabilityGroupName IS NULL OR AvailabilityGroupName = '') OR @Version < 11 OR SERVERPROPERTY('IsHadrEnabled') = 0)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @AvailabilityGroups is not supported.', 16, 1\r\n  END\r\n\r\n  IF (@Databases IS NULL AND @AvailabilityGroups IS NULL)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'You need to specify one of the parameters @Databases and @AvailabilityGroups.', 16, 2\r\n  END\r\n\r\n  IF (@Databases IS NOT NULL AND @AvailabilityGroups IS NOT NULL)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'You can only specify one of the parameters @Databases and @AvailabilityGroups.', 16, 3\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Select filegroups                                                                          //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET @FileGroups = REPLACE(@FileGroups, CHAR(10), '')\r\n  SET @FileGroups = REPLACE(@FileGroups, CHAR(13), '')\r\n\r\n  WHILE CHARINDEX(@StringDelimiter + ' ', @FileGroups) > 0 SET @FileGroups = REPLACE(@FileGroups, @StringDelimiter + ' ', @StringDelimiter)\r\n  WHILE CHARINDEX(' ' + @StringDelimiter, @FileGroups) > 0 SET @FileGroups = REPLACE(@FileGroups, ' ' + @StringDelimiter, @StringDelimiter)\r\n\r\n  SET @FileGroups = LTRIM(RTRIM(@FileGroups));\r\n\r\n  WITH FileGroups1 (StartPosition, EndPosition, FileGroupItem) AS\r\n  (\r\n  SELECT 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FileGroups, 1), 0), LEN(@FileGroups) + 1) AS EndPosition,\r\n         SUBSTRING(@FileGroups, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FileGroups, 1), 0), LEN(@FileGroups) + 1) - 1) AS FileGroupItem\r\n  WHERE @FileGroups IS NOT NULL\r\n  UNION ALL\r\n  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FileGroups, EndPosition + 1), 0), LEN(@FileGroups) + 1) AS EndPosition,\r\n         SUBSTRING(@FileGroups, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FileGroups, EndPosition + 1), 0), LEN(@FileGroups) + 1) - EndPosition - 1) AS FileGroupItem\r\n  FROM FileGroups1\r\n  WHERE EndPosition < LEN(@FileGroups) + 1\r\n  ),\r\n  FileGroups2 (FileGroupItem, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN FileGroupItem LIKE '-%' THEN RIGHT(FileGroupItem,LEN(FileGroupItem) - 1) ELSE FileGroupItem END AS FileGroupItem,\r\n         StartPosition,\r\n         CASE WHEN FileGroupItem LIKE '-%' THEN 0 ELSE 1 END AS Selected\r\n  FROM FileGroups1\r\n  ),\r\n  FileGroups3 (FileGroupItem, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN FileGroupItem = 'ALL_FILEGROUPS' THEN '%.%' ELSE FileGroupItem END AS FileGroupItem,\r\n         StartPosition,\r\n         Selected\r\n  FROM FileGroups2\r\n  ),\r\n  FileGroups4 (DatabaseName, FileGroupName, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN PARSENAME(FileGroupItem,4) IS NULL AND PARSENAME(FileGroupItem,3) IS NULL THEN PARSENAME(FileGroupItem,2) ELSE NULL END AS DatabaseName,\r\n         CASE WHEN PARSENAME(FileGroupItem,4) IS NULL AND PARSENAME(FileGroupItem,3) IS NULL THEN PARSENAME(FileGroupItem,1) ELSE NULL END AS FileGroupName,\r\n         StartPosition,\r\n         Selected\r\n  FROM FileGroups3\r\n  )\r\n  INSERT INTO @SelectedFileGroups (DatabaseName, FileGroupName, StartPosition, Selected)\r\n  SELECT DatabaseName, FileGroupName, StartPosition, Selected\r\n  FROM FileGroups4\r\n  OPTION (MAXRECURSION 0)\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Select objects                                                                             //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET @Objects = REPLACE(@Objects, CHAR(10), '')\r\n  SET @Objects = REPLACE(@Objects, CHAR(13), '')\r\n\r\n  WHILE CHARINDEX(@StringDelimiter + ' ', @Objects) > 0 SET @Objects = REPLACE(@Objects, @StringDelimiter + ' ', @StringDelimiter)\r\n  WHILE CHARINDEX(' ' + @StringDelimiter, @Objects) > 0 SET @Objects = REPLACE(@Objects, ' ' + @StringDelimiter, @StringDelimiter)\r\n\r\n  SET @Objects = LTRIM(RTRIM(@Objects));\r\n\r\n  WITH Objects1 (StartPosition, EndPosition, ObjectItem) AS\r\n  (\r\n  SELECT 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Objects, 1), 0), LEN(@Objects) + 1) AS EndPosition,\r\n         SUBSTRING(@Objects, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Objects, 1), 0), LEN(@Objects) + 1) - 1) AS ObjectItem\r\n  WHERE @Objects IS NOT NULL\r\n  UNION ALL\r\n  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Objects, EndPosition + 1), 0), LEN(@Objects) + 1) AS EndPosition,\r\n         SUBSTRING(@Objects, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Objects, EndPosition + 1), 0), LEN(@Objects) + 1) - EndPosition - 1) AS ObjectItem\r\n  FROM Objects1\r\n  WHERE EndPosition < LEN(@Objects) + 1\r\n  ),\r\n  Objects2 (ObjectItem, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN ObjectItem LIKE '-%' THEN RIGHT(ObjectItem,LEN(ObjectItem) - 1) ELSE ObjectItem END AS ObjectItem,\r\n          StartPosition,\r\n         CASE WHEN ObjectItem LIKE '-%' THEN 0 ELSE 1 END AS Selected\r\n  FROM Objects1\r\n  ),\r\n  Objects3 (ObjectItem, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN ObjectItem = 'ALL_OBJECTS' THEN '%.%.%' ELSE ObjectItem END AS ObjectItem,\r\n         StartPosition,\r\n         Selected\r\n  FROM Objects2\r\n  ),\r\n  Objects4 (DatabaseName, SchemaName, ObjectName, StartPosition, Selected) AS\r\n  (\r\n  SELECT CASE WHEN PARSENAME(ObjectItem,4) IS NULL THEN PARSENAME(ObjectItem,3) ELSE NULL END AS DatabaseName,\r\n         CASE WHEN PARSENAME(ObjectItem,4) IS NULL THEN PARSENAME(ObjectItem,2) ELSE NULL END AS SchemaName,\r\n         CASE WHEN PARSENAME(ObjectItem,4) IS NULL THEN PARSENAME(ObjectItem,1) ELSE NULL END AS ObjectName,\r\n         StartPosition,\r\n         Selected\r\n  FROM Objects3\r\n  )\r\n  INSERT INTO @SelectedObjects (DatabaseName, SchemaName, ObjectName, StartPosition, Selected)\r\n  SELECT DatabaseName, SchemaName, ObjectName, StartPosition, Selected\r\n  FROM Objects4\r\n  OPTION (MAXRECURSION 0)\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Select check commands                                                                      //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET @CheckCommands = REPLACE(@CheckCommands, @StringDelimiter + ' ', @StringDelimiter);\r\n\r\n  WITH CheckCommands (StartPosition, EndPosition, CheckCommand) AS\r\n  (\r\n  SELECT 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @CheckCommands, 1), 0), LEN(@CheckCommands) + 1) AS EndPosition,\r\n         SUBSTRING(@CheckCommands, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @CheckCommands, 1), 0), LEN(@CheckCommands) + 1) - 1) AS CheckCommand\r\n  WHERE @CheckCommands IS NOT NULL\r\n  UNION ALL\r\n  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,\r\n         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @CheckCommands, EndPosition + 1), 0), LEN(@CheckCommands) + 1) AS EndPosition,\r\n         SUBSTRING(@CheckCommands, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @CheckCommands, EndPosition + 1), 0), LEN(@CheckCommands) + 1) - EndPosition - 1) AS CheckCommand\r\n  FROM CheckCommands\r\n  WHERE EndPosition < LEN(@CheckCommands) + 1\r\n  )\r\n  INSERT INTO @SelectedCheckCommands (CheckCommand)\r\n  SELECT CheckCommand\r\n  FROM CheckCommands\r\n  OPTION (MAXRECURSION 0)\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Check input parameters                                                                     //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand NOT IN('CHECKDB','CHECKFILEGROUP','CHECKALLOC','CHECKTABLE','CHECKCATALOG'))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @CheckCommands is not supported.', 16, 1\r\n  END\r\n\r\n  IF EXISTS (SELECT * FROM @SelectedCheckCommands GROUP BY CheckCommand HAVING COUNT(*) > 1)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @CheckCommands is not supported.', 16, 2\r\n  END\r\n\r\n  IF NOT EXISTS (SELECT * FROM @SelectedCheckCommands)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @CheckCommands is not supported.' , 16, 3\r\n  END\r\n\r\n  IF EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKDB')) AND EXISTS (SELECT CheckCommand FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKFILEGROUP','CHECKALLOC','CHECKTABLE','CHECKCATALOG'))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @CheckCommands is not supported.', 16, 4\r\n  END\r\n\r\n  IF EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKFILEGROUP')) AND EXISTS (SELECT CheckCommand FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKALLOC','CHECKTABLE'))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @CheckCommands is not supported.', 16, 5\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @PhysicalOnly NOT IN ('Y','N') OR @PhysicalOnly IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @PhysicalOnly is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @DataPurity NOT IN ('Y','N') OR @DataPurity IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DataPurity is not supported.', 16, 1\r\n  END\r\n\r\n  IF @PhysicalOnly = 'Y' AND @DataPurity = 'Y'\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The parameters @PhysicalOnly and @DataPurity cannot be used together.', 16, 2\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @NoIndex NOT IN ('Y','N') OR @NoIndex IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @NoIndex is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @ExtendedLogicalChecks NOT IN ('Y','N') OR @ExtendedLogicalChecks IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @ExtendedLogicalChecks is not supported.', 16, 1\r\n  END\r\n\r\n  IF @PhysicalOnly = 'Y' AND @ExtendedLogicalChecks = 'Y'\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The parameters @PhysicalOnly and @ExtendedLogicalChecks cannot be used together.', 16, 2\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @TabLock NOT IN ('Y','N') OR @TabLock IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @TabLock is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF EXISTS(SELECT * FROM @SelectedFileGroups WHERE DatabaseName IS NULL OR FileGroupName IS NULL)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @FileGroups is not supported.', 16, 1\r\n  END\r\n\r\n  IF @FileGroups IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedFileGroups)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @FileGroups is not supported.', 16, 2\r\n  END\r\n\r\n  IF @FileGroups IS NOT NULL AND NOT EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKFILEGROUP')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @FileGroups is not supported.', 16, 3\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF EXISTS(SELECT * FROM @SelectedObjects WHERE DatabaseName IS NULL OR SchemaName IS NULL OR ObjectName IS NULL)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @Objects is not supported.', 16, 1\r\n  END\r\n\r\n  IF (@Objects IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedObjects))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @Objects is not supported.', 16, 2\r\n  END\r\n\r\n  IF (@Objects IS NOT NULL AND NOT EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKTABLE'))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @Objects is not supported.', 16, 3\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @MaxDOP < 0 OR @MaxDOP > 64\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @MaxDOP is not supported.', 16, 1\r\n  END\r\n\r\n  IF @MaxDOP IS NOT NULL AND NOT (@Version >= 12.050000 OR SERVERPROPERTY('EngineEdition') IN (5, 8))\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @MaxDOP is not supported. MAXDOP is not available in this version of SQL Server.', 16, 2\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @AvailabilityGroupReplicas NOT IN('ALL','PRIMARY','SECONDARY','PREFERRED_BACKUP_REPLICA') OR @AvailabilityGroupReplicas IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @AvailabilityGroupReplicas is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @Updateability NOT IN('READ_ONLY','READ_WRITE','ALL') OR @Updateability IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @Updateability is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @TimeLimit < 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @TimeLimit is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @LockTimeout < 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @LockTimeout is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @LockMessageSeverity NOT IN(10, 16)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @LockMessageSeverity is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @StringDelimiter IS NULL OR LEN(@StringDelimiter) > 1\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @StringDelimiter is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @DatabaseOrder NOT IN('DATABASE_NAME_ASC','DATABASE_NAME_DESC','DATABASE_SIZE_ASC','DATABASE_SIZE_DESC','DATABASE_LAST_GOOD_CHECK_ASC','DATABASE_LAST_GOOD_CHECK_DESC','REPLICA_LAST_GOOD_CHECK_ASC','REPLICA_LAST_GOOD_CHECK_DESC')\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabaseOrder is not supported.', 16, 1\r\n  END\r\n\r\n  IF @DatabaseOrder IN('DATABASE_LAST_GOOD_CHECK_ASC','DATABASE_LAST_GOOD_CHECK_DESC') AND NOT ((@Version >= 12.06024 AND @Version < 13) OR (@Version >= 13.05026 AND @Version < 14) OR @Version >= 14.0302916)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabaseOrder is not supported. DATABASEPROPERTYEX(''DatabaseName'', ''LastGoodCheckDbTime'') is not available in this version of SQL Server.', 16, 2\r\n  END\r\n\r\n  IF @DatabaseOrder IN('REPLICA_LAST_GOOD_CHECK_ASC','REPLICA_LAST_GOOD_CHECK_DESC') AND @LogToTable = 'N'\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabaseOrder is not supported. You need to provide the parameter @LogToTable = ''Y''.', 16, 3\r\n  END\r\n\r\n  IF @DatabaseOrder IN('DATABASE_LAST_GOOD_CHECK_ASC','DATABASE_LAST_GOOD_CHECK_DESC','REPLICA_LAST_GOOD_CHECK_ASC','REPLICA_LAST_GOOD_CHECK_DESC') AND @CheckCommands <> 'CHECKDB'\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabaseOrder is not supported. You need to provide the parameter @CheckCommands = ''CHECKDB''.', 16, 4\r\n  END\r\n\r\n  IF @DatabaseOrder IS NOT NULL AND SERVERPROPERTY('EngineEdition') = 5\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabaseOrder is not supported. This parameter is not supported in Azure SQL Database.', 16, 5\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @DatabasesInParallel NOT IN('Y','N') OR @DatabasesInParallel IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabasesInParallel is not supported.', 16, 1\r\n  END\r\n\r\n  IF @DatabasesInParallel = 'Y' AND SERVERPROPERTY('EngineEdition') = 5\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @DatabasesInParallel is not supported. This parameter is not supported in Azure SQL Database.', 16, 2\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @LogToTable is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @Execute NOT IN('Y','N') OR @Execute IS NULL\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The value for the parameter @Execute is not supported.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF EXISTS(SELECT * FROM @Errors)\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The documentation is available at https://ola.hallengren.com/sql-server-integrity-check.html.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Check that selected databases and availability groups exist                                //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  SET @ErrorMessage = ''\r\n  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '\r\n  FROM @SelectedDatabases\r\n  WHERE DatabaseName NOT LIKE '%[%]%'\r\n  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)\r\n  IF @@ROWCOUNT > 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The following databases in the @Databases parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1\r\n  END\r\n\r\n  SET @ErrorMessage = ''\r\n  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '\r\n  FROM @SelectedFileGroups\r\n  WHERE DatabaseName NOT LIKE '%[%]%'\r\n  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)\r\n  IF @@ROWCOUNT > 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The following databases in the @FileGroups parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1\r\n  END\r\n\r\n  SET @ErrorMessage = ''\r\n  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '\r\n  FROM @SelectedObjects\r\n  WHERE DatabaseName NOT LIKE '%[%]%'\r\n  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)\r\n  IF @@ROWCOUNT > 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The following databases in the @Objects parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1\r\n  END\r\n\r\n  SET @ErrorMessage = ''\r\n  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(AvailabilityGroupName) + ', '\r\n  FROM @SelectedAvailabilityGroups\r\n  WHERE AvailabilityGroupName NOT LIKE '%[%]%'\r\n  AND AvailabilityGroupName NOT IN (SELECT AvailabilityGroupName FROM @tmpAvailabilityGroups)\r\n  IF @@ROWCOUNT > 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The following availability groups do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1\r\n  END\r\n\r\n  SET @ErrorMessage = ''\r\n  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '\r\n  FROM @SelectedFileGroups\r\n  WHERE DatabaseName NOT LIKE '%[%]%'\r\n  AND DatabaseName IN (SELECT DatabaseName FROM @tmpDatabases)\r\n  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases WHERE Selected = 1)\r\n  IF @@ROWCOUNT > 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The following databases have been selected in the @FileGroups parameter, but not in the @Databases or @AvailabilityGroups parameters: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1\r\n  END\r\n\r\n  SET @ErrorMessage = ''\r\n  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '\r\n  FROM @SelectedObjects\r\n  WHERE DatabaseName NOT LIKE '%[%]%'\r\n  AND DatabaseName IN (SELECT DatabaseName FROM @tmpDatabases)\r\n  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases WHERE Selected = 1)\r\n  IF @@ROWCOUNT > 0\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The following databases have been selected in the @Objects parameter, but not in the @Databases or @AvailabilityGroups parameters: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Check @@SERVERNAME                                                                         //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @@SERVERNAME <> CAST(SERVERPROPERTY('ServerName') AS nvarchar(max)) AND SERVERPROPERTY('IsHadrEnabled') = 1\r\n  BEGIN\r\n    INSERT INTO @Errors ([Message], Severity, [State])\r\n    SELECT 'The @@SERVERNAME does not match SERVERPROPERTY(''ServerName''). See ' + CASE WHEN SERVERPROPERTY('IsClustered') = 0 THEN 'https://docs.microsoft.com/en-us/sql/database-engine/install-windows/rename-a-computer-that-hosts-a-stand-alone-instance-of-sql-server' WHEN SERVERPROPERTY('IsClustered') = 1 THEN 'https://docs.microsoft.com/en-us/sql/sql-server/failover-clusters/install/rename-a-sql-server-failover-cluster-instance' END + '.', 16, 1\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Raise errors                                                                               //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  DECLARE ErrorCursor CURSOR FAST_FORWARD FOR SELECT [Message], Severity, [State] FROM @Errors ORDER BY [ID] ASC\r\n\r\n  OPEN ErrorCursor\r\n\r\n  FETCH ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState\r\n\r\n  WHILE @@FETCH_STATUS = 0\r\n  BEGIN\r\n    RAISERROR('%s', @CurrentSeverity, @CurrentState, @CurrentMessage) WITH NOWAIT\r\n    RAISERROR(@EmptyLine, 10, 1) WITH NOWAIT\r\n\r\n    FETCH NEXT FROM ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState\r\n  END\r\n\r\n  CLOSE ErrorCursor\r\n\r\n  DEALLOCATE ErrorCursor\r\n\r\n  IF EXISTS (SELECT * FROM @Errors WHERE Severity >= 16)\r\n  BEGIN\r\n    SET @ReturnCode = 50000\r\n    GOTO Logging\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Update database order                                                                      //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @DatabaseOrder IN('DATABASE_SIZE_ASC','DATABASE_SIZE_DESC')\r\n  BEGIN\r\n    UPDATE tmpDatabases\r\n    SET DatabaseSize = (SELECT SUM(CAST(size AS bigint)) FROM sys.master_files WHERE [type] = 0 AND database_id = DB_ID(tmpDatabases.DatabaseName))\r\n    FROM @tmpDatabases tmpDatabases\r\n  END\r\n\r\n  IF @DatabaseOrder IN('DATABASE_LAST_GOOD_CHECK_ASC','DATABASE_LAST_GOOD_CHECK_DESC')\r\n  BEGIN\r\n    UPDATE tmpDatabases\r\n    SET LastGoodCheckDbTime = NULLIF(CAST(DATABASEPROPERTYEX (DatabaseName,'LastGoodCheckDbTime') AS datetime2),'1900-01-01 00:00:00.000')\r\n    FROM @tmpDatabases tmpDatabases\r\n  END\r\n\r\n  IF @DatabaseOrder IN('REPLICA_LAST_GOOD_CHECK_ASC','REPLICA_LAST_GOOD_CHECK_DESC')\r\n  BEGIN\r\n    UPDATE tmpDatabases\r\n    SET LastCommandTime = MaxStartTime\r\n    FROM @tmpDatabases tmpDatabases\r\n    INNER JOIN (SELECT DatabaseName, MAX(StartTime) AS MaxStartTime\r\n                FROM dbo.CommandLog\r\n                WHERE CommandType = 'DBCC_CHECKDB'\r\n                AND ErrorNumber = 0\r\n                GROUP BY DatabaseName) CommandLog\r\n    ON tmpDatabases.DatabaseName = CommandLog.DatabaseName COLLATE DATABASE_DEFAULT\r\n  END\r\n\r\n  IF @DatabaseOrder IS NULL\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY StartPosition ASC, DatabaseName ASC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'DATABASE_NAME_ASC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseName ASC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'DATABASE_NAME_DESC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseName DESC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'DATABASE_SIZE_ASC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseSize ASC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'DATABASE_SIZE_DESC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseSize DESC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'DATABASE_LAST_GOOD_CHECK_ASC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY LastGoodCheckDbTime ASC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'DATABASE_LAST_GOOD_CHECK_DESC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY LastGoodCheckDbTime DESC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'REPLICA_LAST_GOOD_CHECK_ASC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY LastCommandTime ASC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n  ELSE\r\n  IF @DatabaseOrder = 'REPLICA_LAST_GOOD_CHECK_DESC'\r\n  BEGIN\r\n    WITH tmpDatabases AS (\r\n    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY LastCommandTime DESC) AS RowNumber\r\n    FROM @tmpDatabases tmpDatabases\r\n    WHERE Selected = 1\r\n    )\r\n    UPDATE tmpDatabases\r\n    SET [Order] = RowNumber\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Update the queue                                                                           //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  IF @DatabasesInParallel = 'Y'\r\n  BEGIN\r\n\r\n    BEGIN TRY\r\n\r\n      SELECT @QueueID = QueueID\r\n      FROM dbo.[Queue]\r\n      WHERE SchemaName = @SchemaName\r\n      AND ObjectName = @ObjectName\r\n      AND [Parameters] = @Parameters\r\n\r\n      IF @QueueID IS NULL\r\n      BEGIN\r\n        BEGIN TRANSACTION\r\n\r\n        SELECT @QueueID = QueueID\r\n        FROM dbo.[Queue] WITH (UPDLOCK, HOLDLOCK)\r\n        WHERE SchemaName = @SchemaName\r\n        AND ObjectName = @ObjectName\r\n        AND [Parameters] = @Parameters\r\n\r\n        IF @QueueID IS NULL\r\n        BEGIN\r\n          INSERT INTO dbo.[Queue] (SchemaName, ObjectName, [Parameters])\r\n          SELECT @SchemaName, @ObjectName, @Parameters\r\n\r\n          SET @QueueID = SCOPE_IDENTITY()\r\n        END\r\n\r\n        COMMIT TRANSACTION\r\n      END\r\n\r\n      BEGIN TRANSACTION\r\n\r\n      UPDATE [Queue]\r\n      SET QueueStartTime = SYSDATETIME(),\r\n          SessionID = @@SPID,\r\n          RequestID = (SELECT request_id FROM sys.dm_exec_requests WHERE session_id = @@SPID),\r\n          RequestStartTime = (SELECT start_time FROM sys.dm_exec_requests WHERE session_id = @@SPID)\r\n      FROM dbo.[Queue] [Queue]\r\n      WHERE QueueID = @QueueID\r\n      AND NOT EXISTS (SELECT *\r\n                      FROM sys.dm_exec_requests\r\n                      WHERE session_id = [Queue].SessionID\r\n                      AND request_id = [Queue].RequestID\r\n                      AND start_time = [Queue].RequestStartTime)\r\n      AND NOT EXISTS (SELECT *\r\n                      FROM dbo.QueueDatabase QueueDatabase\r\n                      INNER JOIN sys.dm_exec_requests ON QueueDatabase.SessionID = session_id AND QueueDatabase.RequestID = request_id AND QueueDatabase.RequestStartTime = start_time\r\n                      WHERE QueueDatabase.QueueID = @QueueID)\r\n\r\n      IF @@ROWCOUNT = 1\r\n      BEGIN\r\n        INSERT INTO dbo.QueueDatabase (QueueID, DatabaseName)\r\n        SELECT @QueueID AS QueueID,\r\n               DatabaseName\r\n        FROM @tmpDatabases tmpDatabases\r\n        WHERE Selected = 1\r\n        AND NOT EXISTS (SELECT * FROM dbo.QueueDatabase WHERE DatabaseName = tmpDatabases.DatabaseName AND QueueID = @QueueID)\r\n\r\n        DELETE QueueDatabase\r\n        FROM dbo.QueueDatabase QueueDatabase\r\n        WHERE QueueID = @QueueID\r\n        AND NOT EXISTS (SELECT * FROM @tmpDatabases tmpDatabases WHERE DatabaseName = QueueDatabase.DatabaseName AND Selected = 1)\r\n\r\n        UPDATE QueueDatabase\r\n        SET DatabaseOrder = tmpDatabases.[Order]\r\n        FROM dbo.QueueDatabase QueueDatabase\r\n        INNER JOIN @tmpDatabases tmpDatabases ON QueueDatabase.DatabaseName = tmpDatabases.DatabaseName\r\n        WHERE QueueID = @QueueID\r\n      END\r\n\r\n      COMMIT TRANSACTION\r\n\r\n      SELECT @QueueStartTime = QueueStartTime\r\n      FROM dbo.[Queue]\r\n      WHERE QueueID = @QueueID\r\n\r\n    END TRY\r\n\r\n    BEGIN CATCH\r\n      IF XACT_STATE() <> 0\r\n      BEGIN\r\n        ROLLBACK TRANSACTION\r\n      END\r\n      SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'')\r\n      RAISERROR('%s',16,1,@ErrorMessage) WITH NOWAIT\r\n      RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n      SET @ReturnCode = ERROR_NUMBER()\r\n      GOTO Logging\r\n    END CATCH\r\n\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Execute commands                                                                           //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  WHILE (1 = 1)\r\n  BEGIN\r\n\r\n    IF @DatabasesInParallel = 'Y'\r\n    BEGIN\r\n      UPDATE QueueDatabase\r\n      SET DatabaseStartTime = NULL,\r\n          SessionID = NULL,\r\n          RequestID = NULL,\r\n          RequestStartTime = NULL\r\n      FROM dbo.QueueDatabase QueueDatabase\r\n      WHERE QueueID = @QueueID\r\n      AND DatabaseStartTime IS NOT NULL\r\n      AND DatabaseEndTime IS NULL\r\n      AND NOT EXISTS (SELECT * FROM sys.dm_exec_requests WHERE session_id = QueueDatabase.SessionID AND request_id = QueueDatabase.RequestID AND start_time = QueueDatabase.RequestStartTime)\r\n\r\n      UPDATE QueueDatabase\r\n      SET DatabaseStartTime = SYSDATETIME(),\r\n          DatabaseEndTime = NULL,\r\n          SessionID = @@SPID,\r\n          RequestID = (SELECT request_id FROM sys.dm_exec_requests WHERE session_id = @@SPID),\r\n          RequestStartTime = (SELECT start_time FROM sys.dm_exec_requests WHERE session_id = @@SPID),\r\n          @CurrentDatabaseName = DatabaseName\r\n      FROM (SELECT TOP 1 DatabaseStartTime,\r\n                         DatabaseEndTime,\r\n                         SessionID,\r\n                         RequestID,\r\n                         RequestStartTime,\r\n                         DatabaseName\r\n            FROM dbo.QueueDatabase\r\n            WHERE QueueID = @QueueID\r\n            AND (DatabaseStartTime < @QueueStartTime OR DatabaseStartTime IS NULL)\r\n            AND NOT (DatabaseStartTime IS NOT NULL AND DatabaseEndTime IS NULL)\r\n            ORDER BY DatabaseOrder ASC\r\n            ) QueueDatabase\r\n    END\r\n    ELSE\r\n    BEGIN\r\n      SELECT TOP 1 @CurrentDBID = ID,\r\n                   @CurrentDatabaseName = DatabaseName\r\n      FROM @tmpDatabases\r\n      WHERE Selected = 1\r\n      AND Completed = 0\r\n      ORDER BY [Order] ASC\r\n    END\r\n\r\n    IF @@ROWCOUNT = 0\r\n    BEGIN\r\n     BREAK\r\n    END\r\n\r\n    SET @CurrentDatabase_sp_executesql = QUOTENAME(@CurrentDatabaseName) + '.sys.sp_executesql'\r\n\r\n    BEGIN\r\n      SET @DatabaseMessage = 'Date and time: ' + CONVERT(nvarchar,SYSDATETIME(),120)\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      SET @DatabaseMessage = 'Database: ' + QUOTENAME(@CurrentDatabaseName)\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n    END\r\n\r\n    SELECT @CurrentUserAccess = user_access_desc,\r\n           @CurrentIsReadOnly = is_read_only,\r\n           @CurrentDatabaseState = state_desc,\r\n           @CurrentInStandby = is_in_standby,\r\n           @CurrentRecoveryModel = recovery_model_desc\r\n    FROM sys.databases\r\n    WHERE [name] = @CurrentDatabaseName\r\n\r\n    BEGIN\r\n      SET @DatabaseMessage = 'State: ' + @CurrentDatabaseState\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      SET @DatabaseMessage = 'Standby: ' + CASE WHEN @CurrentInStandby = 1 THEN 'Yes' ELSE 'No' END\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      SET @DatabaseMessage = 'Updateability: ' + CASE WHEN @CurrentIsReadOnly = 1 THEN 'READ_ONLY' WHEN  @CurrentIsReadOnly = 0 THEN 'READ_WRITE' END\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      SET @DatabaseMessage = 'User access: ' + @CurrentUserAccess\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      SET @DatabaseMessage = 'Recovery model: ' + @CurrentRecoveryModel\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n    END\r\n\r\n    IF @CurrentDatabaseState = 'ONLINE' AND SERVERPROPERTY('EngineEdition') <> 5\r\n    BEGIN\r\n      IF EXISTS (SELECT * FROM sys.database_recovery_status WHERE database_id = DB_ID(@CurrentDatabaseName) AND database_guid IS NOT NULL)\r\n      BEGIN\r\n        SET @CurrentIsDatabaseAccessible = 1\r\n      END\r\n      ELSE\r\n      BEGIN\r\n        SET @CurrentIsDatabaseAccessible = 0\r\n      END\r\n    END\r\n\r\n    IF @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1\r\n    BEGIN\r\n      SELECT @CurrentReplicaID = databases.replica_id\r\n      FROM sys.databases databases\r\n      INNER JOIN sys.availability_replicas availability_replicas ON databases.replica_id = availability_replicas.replica_id\r\n      WHERE databases.[name] = @CurrentDatabaseName\r\n\r\n      SELECT @CurrentAvailabilityGroupID = group_id,\r\n             @CurrentSecondaryRoleAllowConnections = secondary_role_allow_connections_desc\r\n      FROM sys.availability_replicas\r\n      WHERE replica_id = @CurrentReplicaID\r\n\r\n      SELECT @CurrentAvailabilityGroupRole = role_desc\r\n      FROM sys.dm_hadr_availability_replica_states\r\n      WHERE replica_id = @CurrentReplicaID\r\n\r\n      SELECT @CurrentAvailabilityGroup = [name],\r\n             @CurrentAvailabilityGroupBackupPreference = UPPER(automated_backup_preference_desc)\r\n      FROM sys.availability_groups\r\n      WHERE group_id = @CurrentAvailabilityGroupID\r\n    END\r\n\r\n    IF @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1 AND @CurrentAvailabilityGroup IS NOT NULL AND @AvailabilityGroupReplicas = 'PREFERRED_BACKUP_REPLICA'\r\n    BEGIN\r\n      SELECT @CurrentIsPreferredBackupReplica = sys.fn_hadr_backup_is_preferred_replica(@CurrentDatabaseName)\r\n    END\r\n\r\n    IF SERVERPROPERTY('EngineEdition') <> 5\r\n    BEGIN\r\n      SELECT @CurrentDatabaseMirroringRole = UPPER(mirroring_role_desc)\r\n      FROM sys.database_mirroring\r\n      WHERE database_id = DB_ID(@CurrentDatabaseName)\r\n    END\r\n\r\n    IF @CurrentIsDatabaseAccessible IS NOT NULL\r\n    BEGIN\r\n      SET @DatabaseMessage = 'Is accessible: ' + CASE WHEN @CurrentIsDatabaseAccessible = 1 THEN 'Yes' ELSE 'No' END\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n    END\r\n\r\n    IF @CurrentAvailabilityGroup IS NOT NULL\r\n    BEGIN\r\n      SET @DatabaseMessage =  'Availability group: ' + ISNULL(@CurrentAvailabilityGroup,'N/A')\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      SET @DatabaseMessage = 'Availability group role: ' + ISNULL(@CurrentAvailabilityGroupRole,'N/A')\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n      IF @CurrentAvailabilityGroupRole = 'SECONDARY'\r\n      BEGIN\r\n        SET @DatabaseMessage =  'Readable Secondary: ' + ISNULL(@CurrentSecondaryRoleAllowConnections,'N/A')\r\n        RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n      END\r\n\r\n      IF @AvailabilityGroupReplicas = 'PREFERRED_BACKUP_REPLICA'\r\n      BEGIN\r\n        SET @DatabaseMessage = 'Availability group backup preference: ' + ISNULL(@CurrentAvailabilityGroupBackupPreference,'N/A')\r\n        RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n\r\n        SET @DatabaseMessage = 'Is preferred backup replica: ' + CASE WHEN @CurrentIsPreferredBackupReplica = 1 THEN 'Yes' WHEN @CurrentIsPreferredBackupReplica = 0 THEN 'No' ELSE 'N/A' END\r\n        RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n      END\r\n    END\r\n\r\n    IF @CurrentDatabaseMirroringRole IS NOT NULL\r\n    BEGIN\r\n      SET @DatabaseMessage = 'Database mirroring role: ' + @CurrentDatabaseMirroringRole\r\n      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT\r\n    END\r\n\r\n    RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n\r\n    IF @CurrentDatabaseState = 'ONLINE'\r\n    AND NOT (@CurrentUserAccess = 'SINGLE_USER' AND @CurrentIsDatabaseAccessible = 0)\r\n    AND (@CurrentAvailabilityGroupRole = 'PRIMARY' OR @CurrentAvailabilityGroupRole IS NULL OR SERVERPROPERTY('EngineEdition') = 3)\r\n    AND ((@AvailabilityGroupReplicas = 'PRIMARY' AND @CurrentAvailabilityGroupRole = 'PRIMARY') OR (@AvailabilityGroupReplicas = 'SECONDARY' AND @CurrentAvailabilityGroupRole = 'SECONDARY') OR (@AvailabilityGroupReplicas = 'PREFERRED_BACKUP_REPLICA' AND @CurrentIsPreferredBackupReplica = 1) OR @AvailabilityGroupReplicas = 'ALL' OR @CurrentAvailabilityGroupRole IS NULL)\r\n    AND NOT (@CurrentIsReadOnly = 1 AND @Updateability = 'READ_WRITE')\r\n    AND NOT (@CurrentIsReadOnly = 0 AND @Updateability = 'READ_ONLY')\r\n    BEGIN\r\n\r\n      -- Check database\r\n      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKDB') AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n      BEGIN\r\n        SET @CurrentDatabaseContext = CASE WHEN SERVERPROPERTY('EngineEdition') = 5 THEN @CurrentDatabaseName ELSE 'master' END\r\n\r\n        SET @CurrentCommandType = 'DBCC_CHECKDB'\r\n\r\n        SET @CurrentCommand = ''\r\n        IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n        SET @CurrentCommand += 'DBCC CHECKDB (' + QUOTENAME(@CurrentDatabaseName)\r\n        IF @NoIndex = 'Y' SET @CurrentCommand += ', NOINDEX'\r\n        SET @CurrentCommand += ') WITH NO_INFOMSGS, ALL_ERRORMSGS'\r\n        IF @DataPurity = 'Y' SET @CurrentCommand += ', DATA_PURITY'\r\n        IF @PhysicalOnly = 'Y' SET @CurrentCommand += ', PHYSICAL_ONLY'\r\n        IF @ExtendedLogicalChecks = 'Y' SET @CurrentCommand += ', EXTENDED_LOGICAL_CHECKS'\r\n        IF @TabLock = 'Y' SET @CurrentCommand += ', TABLOCK'\r\n        IF @MaxDOP IS NOT NULL SET @CurrentCommand += ', MAXDOP = ' + CAST(@MaxDOP AS nvarchar)\r\n\r\n        EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseContext, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute\r\n        SET @Error = @@ERROR\r\n        IF @Error <> 0 SET @CurrentCommandOutput = @Error\r\n        IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput\r\n      END\r\n\r\n      -- Check filegroups\r\n      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKFILEGROUP')\r\n      AND (@CurrentAvailabilityGroupRole = 'PRIMARY' OR (@CurrentAvailabilityGroupRole = 'SECONDARY' AND @CurrentSecondaryRoleAllowConnections = 'ALL') OR @CurrentAvailabilityGroupRole IS NULL)\r\n      AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n      BEGIN\r\n        SET @CurrentCommand = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT data_space_id AS FileGroupID, name AS FileGroupName, 0 AS [Order], 0 AS Selected, 0 AS Completed FROM sys.filegroups filegroups WHERE [type] <> ''FX'' ORDER BY CASE WHEN filegroups.name = ''PRIMARY'' THEN 1 ELSE 0 END DESC, filegroups.name ASC'\r\n\r\n        INSERT INTO @tmpFileGroups (FileGroupID, FileGroupName, [Order], Selected, Completed)\r\n        EXECUTE @CurrentDatabase_sp_executesql  @stmt = @CurrentCommand\r\n        SET @Error = @@ERROR\r\n        IF @Error <> 0 SET @ReturnCode = @Error\r\n\r\n        IF @FileGroups IS NULL\r\n        BEGIN\r\n          UPDATE tmpFileGroups\r\n          SET tmpFileGroups.Selected = 1\r\n          FROM @tmpFileGroups tmpFileGroups\r\n        END\r\n        ELSE\r\n        BEGIN\r\n          UPDATE tmpFileGroups\r\n          SET tmpFileGroups.Selected = SelectedFileGroups.Selected\r\n          FROM @tmpFileGroups tmpFileGroups\r\n          INNER JOIN @SelectedFileGroups SelectedFileGroups\r\n          ON @CurrentDatabaseName LIKE REPLACE(SelectedFileGroups.DatabaseName,'_','[_]') AND tmpFileGroups.FileGroupName LIKE REPLACE(SelectedFileGroups.FileGroupName,'_','[_]')\r\n          WHERE SelectedFileGroups.Selected = 1\r\n\r\n          UPDATE tmpFileGroups\r\n          SET tmpFileGroups.Selected = SelectedFileGroups.Selected\r\n          FROM @tmpFileGroups tmpFileGroups\r\n          INNER JOIN @SelectedFileGroups SelectedFileGroups\r\n          ON @CurrentDatabaseName LIKE REPLACE(SelectedFileGroups.DatabaseName,'_','[_]') AND tmpFileGroups.FileGroupName LIKE REPLACE(SelectedFileGroups.FileGroupName,'_','[_]')\r\n          WHERE SelectedFileGroups.Selected = 0\r\n\r\n          UPDATE tmpFileGroups\r\n          SET tmpFileGroups.StartPosition = SelectedFileGroups2.StartPosition\r\n          FROM @tmpFileGroups tmpFileGroups\r\n          INNER JOIN (SELECT tmpFileGroups.FileGroupName, MIN(SelectedFileGroups.StartPosition) AS StartPosition\r\n                      FROM @tmpFileGroups tmpFileGroups\r\n                      INNER JOIN @SelectedFileGroups SelectedFileGroups\r\n                      ON @CurrentDatabaseName LIKE REPLACE(SelectedFileGroups.DatabaseName,'_','[_]') AND tmpFileGroups.FileGroupName LIKE REPLACE(SelectedFileGroups.FileGroupName,'_','[_]')\r\n                      WHERE SelectedFileGroups.Selected = 1\r\n                      GROUP BY tmpFileGroups.FileGroupName) SelectedFileGroups2\r\n          ON tmpFileGroups.FileGroupName = SelectedFileGroups2.FileGroupName\r\n        END;\r\n\r\n        WITH tmpFileGroups AS (\r\n        SELECT FileGroupName, [Order], ROW_NUMBER() OVER (ORDER BY StartPosition ASC, FileGroupName ASC) AS RowNumber\r\n        FROM @tmpFileGroups tmpFileGroups\r\n        WHERE Selected = 1\r\n        )\r\n        UPDATE tmpFileGroups\r\n        SET [Order] = RowNumber\r\n\r\n        SET @ErrorMessage = ''\r\n        SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + '.' + QUOTENAME(FileGroupName) + ', '\r\n        FROM @SelectedFileGroups SelectedFileGroups\r\n        WHERE DatabaseName = @CurrentDatabaseName\r\n        AND FileGroupName NOT LIKE '%[%]%'\r\n        AND NOT EXISTS (SELECT * FROM @tmpFileGroups WHERE FileGroupName = SelectedFileGroups.FileGroupName)\r\n        IF @@ROWCOUNT > 0\r\n        BEGIN\r\n          SET @ErrorMessage = 'The following file groups do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.'\r\n          RAISERROR('%s',10,1,@ErrorMessage) WITH NOWAIT\r\n          SET @Error = @@ERROR\r\n          RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n        END\r\n\r\n        WHILE (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n        BEGIN\r\n          SELECT TOP 1 @CurrentFGID = ID,\r\n                       @CurrentFileGroupID = FileGroupID,\r\n                       @CurrentFileGroupName = FileGroupName\r\n          FROM @tmpFileGroups\r\n          WHERE Selected = 1\r\n          AND Completed = 0\r\n          ORDER BY [Order] ASC\r\n\r\n          IF @@ROWCOUNT = 0\r\n          BEGIN\r\n            BREAK\r\n          END\r\n\r\n          -- Does the filegroup exist?\r\n          SET @CurrentCommand = ''\r\n          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n          SET @CurrentCommand += 'IF EXISTS(SELECT * FROM sys.filegroups filegroups WHERE [type] <> ''FX'' AND filegroups.data_space_id = @ParamFileGroupID AND filegroups.[name] = @ParamFileGroupName) BEGIN SET @ParamFileGroupExists = 1 END'\r\n\r\n          BEGIN TRY\r\n            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N'@ParamFileGroupID int, @ParamFileGroupName sysname, @ParamFileGroupExists bit OUTPUT', @ParamFileGroupID = @CurrentFileGroupID, @ParamFileGroupName = @CurrentFileGroupName, @ParamFileGroupExists = @CurrentFileGroupExists OUTPUT\r\n\r\n            IF @CurrentFileGroupExists IS NULL SET @CurrentFileGroupExists = 0\r\n          END TRY\r\n          BEGIN CATCH\r\n            SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'') + CASE WHEN ERROR_NUMBER() = 1222 THEN ', ' + ' The file group ' + QUOTENAME(@CurrentFileGroupName) + ' in the database ' + QUOTENAME(@CurrentDatabaseName) + ' is locked. It could not be checked if the filegroup exists.' ELSE '' END\r\n            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END\r\n            RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT\r\n            RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n\r\n            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)\r\n            BEGIN\r\n              SET @ReturnCode = ERROR_NUMBER()\r\n            END\r\n          END CATCH\r\n\r\n          IF @CurrentFileGroupExists = 1\r\n          BEGIN\r\n            SET @CurrentDatabaseContext = @CurrentDatabaseName\r\n\r\n            SET @CurrentCommandType = 'DBCC_CHECKFILEGROUP'\r\n\r\n            SET @CurrentCommand = ''\r\n            IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n            SET @CurrentCommand += 'DBCC CHECKFILEGROUP (' + QUOTENAME(@CurrentFileGroupName)\r\n            IF @NoIndex = 'Y' SET @CurrentCommand += ', NOINDEX'\r\n            SET @CurrentCommand += ') WITH NO_INFOMSGS, ALL_ERRORMSGS'\r\n            IF @PhysicalOnly = 'Y' SET @CurrentCommand += ', PHYSICAL_ONLY'\r\n            IF @TabLock = 'Y' SET @CurrentCommand += ', TABLOCK'\r\n            IF @MaxDOP IS NOT NULL SET @CurrentCommand += ', MAXDOP = ' + CAST(@MaxDOP AS nvarchar)\r\n\r\n            EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseContext, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute\r\n            SET @Error = @@ERROR\r\n            IF @Error <> 0 SET @CurrentCommandOutput = @Error\r\n            IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput\r\n          END\r\n\r\n          UPDATE @tmpFileGroups\r\n          SET Completed = 1\r\n          WHERE Selected = 1\r\n          AND Completed = 0\r\n          AND ID = @CurrentFGID\r\n\r\n          SET @CurrentFGID = NULL\r\n          SET @CurrentFileGroupID = NULL\r\n          SET @CurrentFileGroupName = NULL\r\n          SET @CurrentFileGroupExists = NULL\r\n\r\n          SET @CurrentDatabaseContext = NULL\r\n          SET @CurrentCommand = NULL\r\n          SET @CurrentCommandOutput = NULL\r\n          SET @CurrentCommandType = NULL\r\n        END\r\n      END\r\n\r\n      -- Check disk space allocation structures\r\n      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKALLOC') AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n      BEGIN\r\n        SET @CurrentDatabaseContext = CASE WHEN SERVERPROPERTY('EngineEdition') = 5 THEN @CurrentDatabaseName ELSE 'master' END\r\n\r\n        SET @CurrentCommandType = 'DBCC_CHECKALLOC'\r\n\r\n        SET @CurrentCommand = ''\r\n        IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n        SET @CurrentCommand += 'DBCC CHECKALLOC (' + QUOTENAME(@CurrentDatabaseName)\r\n        SET @CurrentCommand += ') WITH NO_INFOMSGS, ALL_ERRORMSGS'\r\n        IF @TabLock = 'Y' SET @CurrentCommand += ', TABLOCK'\r\n\r\n        EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseContext, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute\r\n        SET @Error = @@ERROR\r\n        IF @Error <> 0 SET @CurrentCommandOutput = @Error\r\n        IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput\r\n      END\r\n\r\n      -- Check objects\r\n      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKTABLE')\r\n      AND (@CurrentAvailabilityGroupRole = 'PRIMARY' OR (@CurrentAvailabilityGroupRole = 'SECONDARY' AND @CurrentSecondaryRoleAllowConnections = 'ALL') OR @CurrentAvailabilityGroupRole IS NULL)\r\n      AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n      BEGIN\r\n        SET @CurrentCommand = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT schemas.[schema_id] AS SchemaID, schemas.[name] AS SchemaName, objects.[object_id] AS ObjectID, objects.[name] AS ObjectName, RTRIM(objects.[type]) AS ObjectType, 0 AS [Order], 0 AS Selected, 0 AS Completed FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.schema_id = schemas.schema_id LEFT OUTER JOIN sys.tables tables ON objects.object_id = tables.object_id WHERE objects.[type] IN(''U'',''V'') AND EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.object_id = objects.object_id)' + CASE WHEN @Version >= 12 THEN ' AND (tables.is_memory_optimized = 0 OR is_memory_optimized IS NULL)' ELSE '' END + ' ORDER BY schemas.name ASC, objects.name ASC'\r\n\r\n        INSERT INTO @tmpObjects (SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, [Order], Selected, Completed)\r\n        EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand\r\n        SET @Error = @@ERROR\r\n        IF @Error <> 0 SET @ReturnCode = @Error\r\n\r\n        IF @Objects IS NULL\r\n        BEGIN\r\n          UPDATE tmpObjects\r\n          SET tmpObjects.Selected = 1\r\n          FROM @tmpObjects tmpObjects\r\n        END\r\n        ELSE\r\n        BEGIN\r\n          UPDATE tmpObjects\r\n          SET tmpObjects.Selected = SelectedObjects.Selected\r\n          FROM @tmpObjects tmpObjects\r\n          INNER JOIN @SelectedObjects SelectedObjects\r\n          ON @CurrentDatabaseName LIKE REPLACE(SelectedObjects.DatabaseName,'_','[_]') AND tmpObjects.SchemaName LIKE REPLACE(SelectedObjects.SchemaName,'_','[_]') AND tmpObjects.ObjectName LIKE REPLACE(SelectedObjects.ObjectName,'_','[_]')\r\n          WHERE SelectedObjects.Selected = 1\r\n\r\n          UPDATE tmpObjects\r\n          SET tmpObjects.Selected = SelectedObjects.Selected\r\n          FROM @tmpObjects tmpObjects\r\n          INNER JOIN @SelectedObjects SelectedObjects\r\n          ON @CurrentDatabaseName LIKE REPLACE(SelectedObjects.DatabaseName,'_','[_]') AND tmpObjects.SchemaName LIKE REPLACE(SelectedObjects.SchemaName,'_','[_]') AND tmpObjects.ObjectName LIKE REPLACE(SelectedObjects.ObjectName,'_','[_]')\r\n          WHERE SelectedObjects.Selected = 0\r\n\r\n          UPDATE tmpObjects\r\n          SET tmpObjects.StartPosition = SelectedObjects2.StartPosition\r\n          FROM @tmpObjects tmpObjects\r\n          INNER JOIN (SELECT tmpObjects.SchemaName, tmpObjects.ObjectName, MIN(SelectedObjects.StartPosition) AS StartPosition\r\n                      FROM @tmpObjects tmpObjects\r\n                      INNER JOIN @SelectedObjects SelectedObjects\r\n                      ON @CurrentDatabaseName LIKE REPLACE(SelectedObjects.DatabaseName,'_','[_]') AND tmpObjects.SchemaName LIKE REPLACE(SelectedObjects.SchemaName,'_','[_]') AND tmpObjects.ObjectName LIKE REPLACE(SelectedObjects.ObjectName,'_','[_]')\r\n                      WHERE SelectedObjects.Selected = 1\r\n                      GROUP BY tmpObjects.SchemaName, tmpObjects.ObjectName) SelectedObjects2\r\n          ON tmpObjects.SchemaName = SelectedObjects2.SchemaName AND tmpObjects.ObjectName = SelectedObjects2.ObjectName\r\n        END;\r\n\r\n        WITH tmpObjects AS (\r\n        SELECT SchemaName, ObjectName, [Order], ROW_NUMBER() OVER (ORDER BY StartPosition ASC, SchemaName ASC, ObjectName ASC) AS RowNumber\r\n        FROM @tmpObjects tmpObjects\r\n        WHERE Selected = 1\r\n        )\r\n        UPDATE tmpObjects\r\n        SET [Order] = RowNumber\r\n\r\n        SET @ErrorMessage = ''\r\n        SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + '.' + QUOTENAME(SchemaName) + '.' + QUOTENAME(ObjectName) + ', '\r\n        FROM @SelectedObjects SelectedObjects\r\n        WHERE DatabaseName = @CurrentDatabaseName\r\n        AND SchemaName NOT LIKE '%[%]%'\r\n        AND ObjectName NOT LIKE '%[%]%'\r\n        AND NOT EXISTS (SELECT * FROM @tmpObjects WHERE SchemaName = SelectedObjects.SchemaName AND ObjectName = SelectedObjects.ObjectName)\r\n        IF @@ROWCOUNT > 0\r\n        BEGIN\r\n          SET @ErrorMessage = 'The following objects do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.'\r\n          RAISERROR('%s',10,1,@ErrorMessage) WITH NOWAIT\r\n          SET @Error = @@ERROR\r\n          RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n        END\r\n\r\n        WHILE (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n        BEGIN\r\n          SELECT TOP 1 @CurrentOID = ID,\r\n                       @CurrentSchemaID = SchemaID,\r\n                       @CurrentSchemaName = SchemaName,\r\n                       @CurrentObjectID = ObjectID,\r\n                       @CurrentObjectName = ObjectName,\r\n                       @CurrentObjectType = ObjectType\r\n          FROM @tmpObjects\r\n          WHERE Selected = 1\r\n          AND Completed = 0\r\n          ORDER BY [Order] ASC\r\n\r\n          IF @@ROWCOUNT = 0\r\n          BEGIN\r\n            BREAK\r\n          END\r\n\r\n          -- Does the object exist?\r\n          SET @CurrentCommand = ''\r\n          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n          SET @CurrentCommand += 'IF EXISTS(SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.schema_id = schemas.schema_id LEFT OUTER JOIN sys.tables tables ON objects.object_id = tables.object_id WHERE objects.[type] IN(''U'',''V'') AND EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.object_id = objects.object_id)' + CASE WHEN @Version >= 12 THEN ' AND (tables.is_memory_optimized = 0 OR is_memory_optimized IS NULL)' ELSE '' END + ' AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType) BEGIN SET @ParamObjectExists = 1 END'\r\n\r\n          BEGIN TRY\r\n            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N'@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamObjectExists bit OUTPUT', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamObjectExists = @CurrentObjectExists OUTPUT\r\n\r\n            IF @CurrentObjectExists IS NULL SET @CurrentObjectExists = 0\r\n          END TRY\r\n          BEGIN CATCH\r\n            SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'') + CASE WHEN ERROR_NUMBER() = 1222 THEN ', ' + 'The object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the object exists.' ELSE '' END\r\n            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END\r\n            RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT\r\n            RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n\r\n            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)\r\n            BEGIN\r\n              SET @ReturnCode = ERROR_NUMBER()\r\n            END\r\n          END CATCH\r\n\r\n          IF @CurrentObjectExists = 1\r\n          BEGIN\r\n            SET @CurrentDatabaseContext = @CurrentDatabaseName\r\n\r\n            SET @CurrentCommandType = 'DBCC_CHECKTABLE'\r\n\r\n            SET @CurrentCommand = ''\r\n            IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n            SET @CurrentCommand += 'DBCC CHECKTABLE (''' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ''''\r\n            IF @NoIndex = 'Y' SET @CurrentCommand += ', NOINDEX'\r\n            SET @CurrentCommand += ') WITH NO_INFOMSGS, ALL_ERRORMSGS'\r\n            IF @DataPurity = 'Y' SET @CurrentCommand += ', DATA_PURITY'\r\n            IF @PhysicalOnly = 'Y' SET @CurrentCommand += ', PHYSICAL_ONLY'\r\n            IF @ExtendedLogicalChecks = 'Y' SET @CurrentCommand += ', EXTENDED_LOGICAL_CHECKS'\r\n            IF @TabLock = 'Y' SET @CurrentCommand += ', TABLOCK'\r\n            IF @MaxDOP IS NOT NULL SET @CurrentCommand += ', MAXDOP = ' + CAST(@MaxDOP AS nvarchar)\r\n\r\n            EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseContext, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @LogToTable = @LogToTable, @Execute = @Execute\r\n            SET @Error = @@ERROR\r\n            IF @Error <> 0 SET @CurrentCommandOutput = @Error\r\n            IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput\r\n          END\r\n\r\n          UPDATE @tmpObjects\r\n          SET Completed = 1\r\n          WHERE Selected = 1\r\n          AND Completed = 0\r\n          AND ID = @CurrentOID\r\n\r\n          SET @CurrentOID = NULL\r\n          SET @CurrentSchemaID = NULL\r\n          SET @CurrentSchemaName = NULL\r\n          SET @CurrentObjectID = NULL\r\n          SET @CurrentObjectName = NULL\r\n          SET @CurrentObjectType = NULL\r\n          SET @CurrentObjectExists = NULL\r\n\r\n          SET @CurrentDatabaseContext = NULL\r\n          SET @CurrentCommand = NULL\r\n          SET @CurrentCommandOutput = NULL\r\n          SET @CurrentCommandType = NULL\r\n        END\r\n      END\r\n\r\n      -- Check catalog\r\n      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKCATALOG') AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)\r\n      BEGIN\r\n        SET @CurrentDatabaseContext = CASE WHEN SERVERPROPERTY('EngineEdition') = 5 THEN @CurrentDatabaseName ELSE 'master' END\r\n\r\n        SET @CurrentCommandType = 'DBCC_CHECKCATALOG'\r\n\r\n        SET @CurrentCommand = ''\r\n        IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '\r\n        SET @CurrentCommand += 'DBCC CHECKCATALOG (' + QUOTENAME(@CurrentDatabaseName)\r\n        SET @CurrentCommand += ') WITH NO_INFOMSGS'\r\n\r\n        EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseContext, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute\r\n        SET @Error = @@ERROR\r\n        IF @Error <> 0 SET @CurrentCommandOutput = @Error\r\n        IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput\r\n      END\r\n\r\n    END\r\n\r\n    IF @CurrentDatabaseState = 'SUSPECT'\r\n    BEGIN\r\n      SET @ErrorMessage = 'The database ' + QUOTENAME(@CurrentDatabaseName) + ' is in a SUSPECT state.'\r\n      RAISERROR('%s',16,1,@ErrorMessage) WITH NOWAIT\r\n      SET @Error = @@ERROR\r\n      RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n    END\r\n\r\n    -- Update that the database is completed\r\n    IF @DatabasesInParallel = 'Y'\r\n    BEGIN\r\n      UPDATE dbo.QueueDatabase\r\n      SET DatabaseEndTime = SYSDATETIME()\r\n      WHERE QueueID = @QueueID\r\n      AND DatabaseName = @CurrentDatabaseName\r\n    END\r\n    ELSE\r\n    BEGIN\r\n      UPDATE @tmpDatabases\r\n      SET Completed = 1\r\n      WHERE Selected = 1\r\n      AND Completed = 0\r\n      AND ID = @CurrentDBID\r\n    END\r\n\r\n    -- Clear variables\r\n    SET @CurrentDBID = NULL\r\n    SET @CurrentDatabaseName = NULL\r\n\r\n    SET @CurrentDatabase_sp_executesql = NULL\r\n\r\n    SET @CurrentUserAccess = NULL\r\n    SET @CurrentIsReadOnly = NULL\r\n    SET @CurrentDatabaseState = NULL\r\n    SET @CurrentInStandby = NULL\r\n    SET @CurrentRecoveryModel = NULL\r\n\r\n    SET @CurrentIsDatabaseAccessible = NULL\r\n    SET @CurrentReplicaID = NULL\r\n    SET @CurrentAvailabilityGroupID = NULL\r\n    SET @CurrentAvailabilityGroup = NULL\r\n    SET @CurrentAvailabilityGroupRole = NULL\r\n    SET @CurrentAvailabilityGroupBackupPreference = NULL\r\n    SET @CurrentSecondaryRoleAllowConnections = NULL\r\n    SET @CurrentIsPreferredBackupReplica = NULL\r\n    SET @CurrentDatabaseMirroringRole = NULL\r\n\r\n    SET @CurrentDatabaseContext = NULL\r\n    SET @CurrentCommand = NULL\r\n    SET @CurrentCommandOutput = NULL\r\n    SET @CurrentCommandType = NULL\r\n\r\n    DELETE FROM @tmpFileGroups\r\n    DELETE FROM @tmpObjects\r\n\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n  --// Log completing information                                                                 //--\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\n  Logging:\r\n  SET @EndMessage = 'Date and time: ' + CONVERT(NVARCHAR,SYSDATETIME(),120)\r\n  RAISERROR('%s',10,1,@EndMessage) WITH NOWAIT\r\n\r\n  RAISERROR(@EmptyLine,10,1) WITH NOWAIT\r\n\r\n  IF @ReturnCode <> 0\r\n  BEGIN\r\n    RETURN @ReturnCode\r\n  END\r\n\r\n  ----------------------------------------------------------------------------------------------------\r\n\r\nEND\r\n\r\nGO\r\n\r\n\r\n"
}