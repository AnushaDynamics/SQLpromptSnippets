{
  "id": "b4240993-f437-42d8-9050-261870a315df",
  "prefix": "SplitString_CSV",
  "description": "Split String Based on Delimiter - Direct Method",
  "body": "-- These Methods are same as STRING_SPLIT (Introduced from SQL Server 2016 (13.x)) But Compatible for < 130 Compactibility\r\n-- https://docs.microsoft.com/en-us/sql/t-sql/functions/string-split-transact-sql?view=sql-server-ver15\r\n--\r\n--$BeginRegion: Version-1 --Low Cost Execution Plan But Slow Execution\r\n--Note: Works Good for All Delimiters and Any Kind of Output Values that Contains any Symbols other than Delimiter\r\nDECLARE @CSVstring NVARCHAR(MAX) = 'a,b,c,d,1,2,3,~,`,!,@,#,$,%,^,&,*,(,),-,_,=,+,[,],{,},\\,|,;,:,\",'',<,>,.,/,?';\r\nDECLARE @Delimiter CHAR(1) = ',';\r\n--\r\n;WITH _CSV_vals\r\nAS (\r\n\t   SELECT SUBSTRING((@CSVstring + @Delimiter), 1, CHARINDEX(@Delimiter, (@CSVstring + @Delimiter), 1) - 1) AS \"val\",\r\n\t\t\t  SUBSTRING((@CSVstring + @Delimiter), CHARINDEX(@Delimiter, (@CSVstring + @Delimiter), 1) + 1, LEN((@CSVstring + @Delimiter))) AS \"rem\"\r\n\t   UNION ALL\r\n\t   SELECT SUBSTRING(a.rem, 1, CHARINDEX(@Delimiter, a.rem, 1) - 1) AS \"val\",\r\n\t\t\t  SUBSTRING(a.rem, CHARINDEX(@Delimiter, a.rem, 1) + 1, LEN(a.rem))\r\n\t   FROM _CSV_vals AS a\r\n\t   WHERE LEN(a.rem) >= 1\r\n   )\r\nSELECT --ROW_NUMBER() OVER (ORDER BY CSV.val ASC) AS \"Id\", --Returns Incremental Order of Value in @CSVstring\r\n\t   ROW_NUMBER() OVER (ORDER BY (SELECT 0)) AS \"Id\", --*Returns Actual Order of Value in @CSVstring --Intuitive, But Might Get Wrong Order\r\n\t   CSV.val AS \"Value\"\r\nFROM _CSV_vals AS CSV\r\nOPTION (MAXRECURSION 0);\r\n--$EndRegion: Version-1 --Low Cost Execution Plan But Slow Execution\r\n--\r\nGO\r\n--\r\n--$BeginRegion: Version-2 --High Cost Execution Plan But Speed Execution\r\n--Note: Works Good for All Delimiters Except If String Contains these symbols \"&\", \"<\", \">\" as part of Output Values\r\nDECLARE @CSVstring NVARCHAR(MAX) = 'a,b,c,d,1,2,3,~,`,!,@,#,$,%,^,*,(,),-,_,=,+,[,],{,},\\,|,;,:,\",'',.,/,?';\r\nDECLARE @Delimiter AS CHAR(1) = ',';\r\n--\r\nDECLARE @XML AS XML;\r\nSET @XML = CAST(('<x>' + REPLACE(@CSVstring, @Delimiter, '</x><x>') + '</x>') AS XML);\r\n\r\nSELECT --ROW_NUMBER() OVER (ORDER BY T.N.value('.', 'varchar') ASC) AS \"Id\", --Returns Incremental Order of Value in @CSVstring\r\n\t   --ROW_NUMBER() OVER (ORDER BY (SELECT 0)) AS \"Id\", --*Returns Actual Order of Value in @CSVstring --Intuitive, But Might Get Wrong Order\r\n\t   T.N.value('let $n := . return count(../*[. << $n]) + 1', 'int') AS \"Id\", --Returns Actual Order of Value in @CSVstring\r\n\t   T.N.value('.', 'nvarchar(max)') AS \"Value\"\r\nFROM @XML.nodes('x') AS T(N);\r\n--$EndRegion: Version-2 --High Cost Execution Plan But Speed Execution\r\n--\r\nGO\r\n--\r\n--$BeginRegion: Version-3 --Similar To Version-1 But By Default Id Generates the Actual Order of Value in @CSVstring\r\nDECLARE @CSVstring VARCHAR(4000) = 'a,b,c,d,1,2,3,~,`,!,@,#,$,%,^,&,*,(,),-,_,=,+,[,],{,},\\,|,;,:,\",'',<,>,.,/,?';\r\nDECLARE @Delimiter CHAR(1) = ',';\r\n\r\nSET NOCOUNT ON;\r\nDECLARE @CSVvalues TABLE\r\n(\r\n\tId INT NOT NULL,\r\n\t[Value] VARCHAR(256) NULL\r\n);\r\n\r\nIF @CSVstring NOT LIKE '%' + @Delimiter OR @CSVstring LIKE '% '\r\n\tSELECT @CSVstring = @CSVstring + @Delimiter;\r\n\r\nDECLARE @i INT; SET @i = 1;\r\nWHILE (DATALENGTH(@CSVstring) > 1)\r\nBEGIN\r\n\tBEGIN TRY\r\n\t\tINSERT INTO @CSVvalues (Id, [Value])\r\n\t\tVALUES (@i, SUBSTRING(@CSVstring, 1, CHARINDEX(@Delimiter, @CSVstring) - 1));\r\n\t\t--\r\n\t\tSET @CSVstring = SUBSTRING(@CSVstring, CHARINDEX(@Delimiter, @CSVstring) + 1, DATALENGTH(@CSVstring));\r\n\tEND TRY\r\n\tBEGIN CATCH\r\n\t\tBREAK;\r\n\tEND CATCH;\r\n\t--\r\n\tSET @i = @i + 1;\r\nEND;\r\n\r\nSELECT Id, [Value] FROM @CSVvalues;\r\n--$EndRegion: Version-3 --Similar To Version-1 But By Default Id Generates the Actual Order of Value in @CSVstring"
}