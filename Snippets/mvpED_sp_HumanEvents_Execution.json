{
  "id": "b922a605-51a7-489f-b787-dc0eca8154cf",
  "prefix": "mvpED_sp_HumanEvents_Execution",
  "description": "This tool script was written to as a companion to sp_HumanEvents",
  "body": "-- Here are some example calls to get you started.\r\n\r\n-- To capture all types of ‚Äúcompleted‚Äù queries that have run for at least one second, for 20 seconds, from a specific database\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'query', \r\n    @query_duration_ms = 1000, \r\n    @seconds_sample = 20, \r\n    @database_name = 'YourMom';\r\n\r\n-- Maybe you want to filter out queries that have asked for a bit of memory:\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'query', \r\n    @query_duration_ms = 1000, \r\n    @seconds_sample = 20, \r\n    @requested_memory_mb = 1024;\r\n\r\n-- Or maybe you want to find unparameterized queries from a poorly written app that constructs strings in ugly ways, but it generates a lot of queries so you only want data on about a third of them.\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'compilations', \r\n    @client_app_name = N'GL00SNIF–Ø', \r\n    @session_id = 'sample', \r\n    @sample_divisor = 3;\r\n\r\n-- Perhaps you think queries recompiling are the cause of your problems! Heck, they might be. Have you tried removing recompile hints? üòÅ\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'recompilations', \r\n    @seconds_sample = 30;\r\n\r\n-- Look, blocking is annoying. Just turn on RCSI, you goblin. Unless you‚Äôre not allowed to.\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'blocking', \r\n    @seconds_sample = 60, \r\n    @blocking_duration_ms = 5000;\r\n\r\n-- If you want to track wait stats, this‚Äôll work pretty well. Keep in mind ‚Äúall‚Äù is a focused list of ‚Äúinteresting‚Äù waits to queries, not every wait stat.\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'waits', \r\n    @wait_duration_ms = 10,\r\n    @seconds_sample = 100, \r\n    @wait_type = N'all';\r\n\r\n-- Note that THREADPOOL is SOS_WORKER in xe-land. why? I dunno.\r\n\r\nEXEC dbo.sp_HumanEvents \r\n    @event_type = 'waits', \r\n    @wait_duration_ms = 100, \r\n    @seconds_sample = 10, \r\n    @wait_type = N'SOS_WORKER,RESOURCE_SEMAPHORE';\r\n\r\n-- For some event types that allow you to set a minimum duration, I‚Äôve set a default minimum to try to avoid you introducing a lot of observer overhead to the server. If you understand the potential danger here, or you‚Äôre just trying to test things, you need to use the @gimme_danger parameter. You would also use this if you wanted to set an impermanent session to run for longer than 10 minutes.\r\n\r\n-- For example, if you run this command:\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'query', \r\n    @query_duration_ms = 1;\r\n\r\n-- You‚Äôll see this message in the output:\r\n\r\n-- Checking query duration filter\r\n-- You chose a really dangerous value for @query_duration\r\n-- If you really want that, please set @gimme_danger = 1, and re-run\r\n-- Setting @query_duration to 500\r\n\r\n\r\n-- You need to use this command instead:\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'query', \r\n    @query_duration_ms = 1, \r\n    @gimme_danger = 1;\r\n\r\n--  Logging Data To Tables\r\n\r\n-- First, you need to set up permanent sessions to collect data. You can use commands like these to do that, but I urge you to add some filters like above to cut down on the data collected. On busy servers, over-collection can cause performance issues.\r\n\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'compiles', \r\n    @keep_alive = 1;\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'recompiles', \r\n    @keep_alive = 1;\r\n\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'query', \r\n    @keep_alive = 1;\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'waits', \r\n    @keep_alive = 1;\r\n\r\nEXEC sp_HumanEvents \r\n    @event_type = N'blocking', \r\n    @keep_alive = 1;\r\n\r\n\r\n-- Once your sessions are set up, this is the command to tell sp_HumanEvents which database and schema to log data to. \r\n-- Table names are created internally, so don‚Äôt worry about those.\r\n\r\nEXEC sp_HumanEvents \r\n    @output_database_name = N'YourDatabase', \r\n    @output_schema_name = N'dbo';\r\n\r\n-- Ideally, you‚Äôll stick this in an Agent Job, so you don‚Äôt need to rely on an SSMS window being open all the time. \r\n-- The job creation code linked is set to check in every 10 seconds, in case of errors. \r\n-- Internally, this will run in its own loop with a WAITFOR of 5 seconds to flush data out.\r\n\r\n\r\n-- Part of what gets installed when you log data to tables are some views in the same database.\r\n\r\n-- You can check in on them like this:\r\n\r\n/*Queries*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_Queries;\r\n/*Waits*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_WaitsByQueryAndDatabase;\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_WaitsByDatabase;\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_WaitsTotal;\r\n/*Blocking*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_Blocking;\r\n/*Compiles, only on newer versions of SQL Server*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_CompilesByDatabaseAndObject;\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_CompilesByQuery;\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_CompilesByDuration;\r\n/*Otherwise*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_Compiles_Legacy;\r\n/*Parameterization data, if available (comes along with compiles)*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_Parameterization;\r\n/*Recompiles, only on newer versions of SQL Server*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_RecompilesByDatabaseAndObject;\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_RecompilesByQuery;\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_RecompilesByDuration;\r\n/*Otherwise*/\r\nSELECT TOP 1000 * FROM dbo.HumanEvents_Recompiles_Legacy;"
}