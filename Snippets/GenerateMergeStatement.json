{
  "id": "264cbb75-fb36-4a19-aa73-f63a0eada290",
  "prefix": "GenerateMergeStatement",
  "description": "Generating Merge Statement to Sync Data in Source Table and Destination Table",
  "body": "/* =============================================================================================================================================================\r\n-- Database\t\t: Target Database.\r\n-- Script\t\t: Generating Merge Statement to Sync Data in Source Table and Destination Table.\r\n-- Note:\t**Source Server CAN be Local or Linked Server.\r\n--\t\t\t**But Target Server CANNOT be Linked Server (i.e., Merge Statement Cannot Write Data in Target If It is a Linked Server).\r\n--\t\t\tSo, We need to create a Merge Statement using linked Server (with Data Access) as Source for referencing the Data but not for inserting the Data.\r\n--\t\t\tAnd We Need to Execute the Query in the Subscriber Server or in the Target Server where exactly you need to Write(DML) to Table Data.\r\n============================================================================================================================================================= */\r\n--\r\nDECLARE --\r\n\t@SourceServer AS VARCHAR(256) = '$SourceLinkedServer$', -- Source Can Be LinkedServer Where Data Can Be Read But Target Cannot Be LinkedServer.\r\n\t@SourceDatabase AS VARCHAR(256) = '$SourceDatabase$',\r\n\t@TargetDatabase AS VARCHAR(256) = '$TargetDatabase$',\r\n\t@SourceSchema AS VARCHAR(256) = '$SourceSchema$',\r\n\t@TargetSchema AS VARCHAR(256) = '$TargetSchema$',\r\n\t@SourceTable AS VARCHAR(256) = '$SourceTable$',\r\n\t@TargetTable AS VARCHAR(256) = '$TargetTable$';\r\n--\r\nDECLARE --To Include/Exclude Statements for Insert, Update, Delete\r\n\t@IncludeInsert INT = 1, -- 1 = Included (Default) | 0 = Excluded\r\n\t@IncludeUpdate INT = 1, -- 1 = Included (Default) | 0 = Excluded\r\n\t@IncludeDelete INT = 1; -- 1 = Included (Default) | 0 = Excluded\r\n--\r\nDECLARE @Debug BIT = 1;\t\t-- 1 = Print Debug | 0 = Excluded (Default)\r\n--AS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\t-- Assumptions\r\n\t-- The names of the columns are the same in both tables.\r\n\t-- There should be PrimaryKey(PK can be Composite) => If Not PK, Identity Value should be Present.\r\n\tDECLARE @SQLstring AS NVARCHAR(MAX);\r\n\r\n\t--$BeginRegion: Source and Target Objects Check\r\n\tDECLARE @ReturnINT INT, @ReturnTXT VARCHAR(256);\r\n\t----$BeginRegion: Source Server Check\r\n\tIF TRIM(@SourceServer) = ''\r\n\t\tSET @SourceServer = NULL;\r\n\tIF @SourceServer IS NOT NULL\r\n\tBEGIN\r\n\t\tSET @SQLstring = --\r\n\t\tN'IF EXISTS (SELECT 1 FROM master.sys.servers WHERE name = ''' + @SourceServer + N''')\r\n\t\t\tIF EXISTS (SELECT 1 FROM master.sys.servers WHERE name = ''' + @SourceServer + N''' AND is_data_access_enabled = 1)\r\n\t\t\t\tSET @ReturnOUT1 = 0;\r\n\t\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Server Exists But Data Access Is Not Enabled..!''; END;\r\n\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Server Does Not Exists..!''; END;';\r\n\t\tEXECUTE sys.sp_executesql @CMD = @SQLstring, @PARAM = N'@ReturnOUT1 INT OUTPUT, @ReturnOUT2 VARCHAR(256) OUTPUT', @ReturnOUT1 = @ReturnINT OUTPUT, @ReturnOUT2 = @ReturnTXT OUTPUT;\r\n\t\tIF @ReturnINT = 1\r\n\t\tBEGIN\r\n\t\t\tSELECT @ReturnTXT AS \"ErrorMessage..!\";\r\n\t\t\tRAISERROR(@ReturnTXT, 16, 1) WITH NOWAIT;\r\n\t\t\tRETURN;\t    \r\n\t\tEND;\r\n\tEND;\r\n\t----$EndRegion: Source Server Check\r\n\t--\r\n\t----$BeginRegion: Source Object Check\r\n\tSET @SQLstring = --\r\n\tN'IF EXISTS (SELECT 1 FROM ' + ISNULL(@SourceServer + '.', '') + N'master.sys.databases WHERE name = ''' + @SourceDatabase + N''')\r\n\t\tIF EXISTS (SELECT 1 FROM ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.schemas WHERE name = ''' + @SourceSchema + N''')\r\n\t\t\tIF EXISTS (SELECT 1 FROM ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.tables AS TBL INNER JOIN ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id WHERE SCH.name = ''' + @SourceSchema + N''' AND TBL.name = ''' + @SourceTable + N''')\r\n\t\t\t\tSET @ReturnOUT1 = 0;\r\n\t\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Database And Source Schema Exists But Source Table Does Not Exists..!''; END;\r\n\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Database Exists But Source Schema Does Not Exists..!''; END;\r\n\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Database Does Not Exists..!''; END;';\r\n\tEXECUTE sys.sp_executesql @CMD = @SQLstring, @PARAM = N'@ReturnOUT1 INT OUTPUT, @ReturnOUT2 VARCHAR(256) OUTPUT', @ReturnOUT1 = @ReturnINT OUTPUT, @ReturnOUT2 = @ReturnTXT OUTPUT;\r\n\tIF @ReturnINT = 1\r\n\tBEGIN\r\n\t\tSELECT @ReturnTXT AS \"ErrorMessage..!\";\r\n\t\tRAISERROR(@ReturnTXT, 16, 1) WITH NOWAIT;\r\n\t\tRETURN;\t    \r\n\tEND;\r\n\t----$EndRegion: Source Object Check\r\n\t--\r\n\t----$BeginRegion: Target Object Check\r\n\tSET @SQLstring = --\r\n\tN'IF EXISTS (SELECT 1 FROM sys.databases WHERE name = ''' + @TargetDatabase + N''')\r\n\t\tIF EXISTS (SELECT 1 FROM ' + @TargetDatabase + N'.sys.schemas WHERE name = ''' + @TargetSchema + N''')\r\n\t\t\tIF EXISTS (SELECT 1 FROM ' + @TargetDatabase + N'.sys.tables AS TBL INNER JOIN ' + @TargetDatabase + N'.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id WHERE SCH.name = ''' + @TargetSchema + N''' AND TBL.name = ''' + @TargetTable + N''')\r\n\t\t\t\tSET @ReturnOUT1 = 0;\r\n\t\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Target Database And Target Schema Exists But Target Table Does Not Exists..!''; END;\r\n\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Target Database Exists But Target Schema Does Not Exists..!''; END;\r\n\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Target Database Does Not Exists..!''; END;';\r\n\tEXECUTE sys.sp_executesql @CMD = @SQLstring, @PARAM = N'@ReturnOUT1 INT OUTPUT, @ReturnOUT2 VARCHAR(256) OUTPUT', @ReturnOUT1 = @ReturnINT OUTPUT, @ReturnOUT2 = @ReturnTXT OUTPUT;\r\n\tIF @ReturnINT = 1\r\n\tBEGIN\r\n\t\tSELECT @ReturnTXT AS \"ErrorMessage..!\";\r\n\t\tRAISERROR(@ReturnTXT, 16, 1) WITH NOWAIT;\r\n\t\tRETURN;\t    \r\n\tEND;\r\n\t----$EndRegion: Target Object Check\r\n\t--$EndRegion: Source and Target Objects Check\r\n\t----\r\n\t--$BeginRegion: To Get All Columns in the SourceSchema.SourceTable\r\n\tDECLARE @TableColumns TABLE\r\n\t(\r\n\tColID INT NULL, --ORDINAL_POSITION\r\n\tColumnName VARCHAR(256) NULL,\r\n\tColumnDataType VARCHAR(64) NULL,\r\n\tIsPrimaryKeyCol BIT NULL,\r\n\tIsComputedCol BIT NULL,\r\n\tIsIdentityCol BIT NULL\r\n\t);\r\n\t--\r\n\tSET @SQLstring --\r\n\t\t= N'SELECT DISTINCT COL.column_id, COL.name, ISC.DATA_TYPE, ISNULL(PKC.Is_PK, 0), COL.is_computed, COL.is_identity' + CHAR(10) --\r\n\t\t+ N'FROM ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.columns AS COL' + CHAR(10) --\r\n\t\t+ N'INNER JOIN ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.tables AS TBL ON TBL.object_id = COL.object_id' + CHAR(10) --\r\n\t\t+ N'INNER JOIN ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id' + CHAR(10) --\r\n\t\t+ N'INNER JOIN ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.INFORMATION_SCHEMA.COLUMNS AS ISC ON ISC.TABLE_SCHEMA = SCH.name AND ISC.TABLE_NAME = TBL.name AND ISC.COLUMN_NAME = COL.name' + CHAR(10) --\r\n\t\t+ N'LEFT JOIN (' + CHAR(10) --\r\n\t\t+ N'\t\t\tSELECT IC.object_id, IC.column_id, 1 AS \"Is_PK\"' + CHAR(10) --\r\n\t\t+ N'\t\t\tFROM ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.index_columns AS IC' + CHAR(10) --\r\n\t\t+ N'\t\t\tINNER JOIN ' + ISNULL(@SourceServer + '.', '') + @SourceDatabase + N'.sys.key_constraints AS KC ON IC.object_id = KC.parent_object_id AND IC.index_id = KC.unique_index_id AND KC.type = ''PK''' + CHAR(10) --\r\n\t\t+ N'\t\t  ) AS PKC ON PKC.column_id = COL.column_id AND PKC.object_id = COL.object_id' + CHAR(10) --\r\n\t\t+ N'WHERE SCH.name = ''' + @SourceSchema + N''' AND TBL.name = ''' + @SourceTable + N'''' + CHAR(10) --\r\n\t\t+ N'ORDER BY COL.column_id ASC;';\r\n\t\t--PRINT @SQLstring;\r\n\t--\r\n\tINSERT INTO @TableColumns\r\n\t(\r\n\t\tColID,\r\n\t\tColumnName,\r\n\t\tColumnDataType,\r\n\t\tIsPrimaryKeyCol,\r\n\t\tIsComputedCol,\r\n\t\tIsIdentityCol\r\n\t)\r\n\tEXEC sys.sp_executesql @statement = @SQLstring;\r\n\tIF @Debug = 1\r\n\tBEGIN\r\n\t\tSELECT ISNULL(@SourceServer, 'LocalServer') AS \"SourceServer\", @SourceDatabase AS \"SourceDatabase\", @SourceSchema AS \"SourceSchema\", @SourceTable AS \"SourceTable\",\r\n\t\t\t   TC.ColID, TC.ColumnName, TC.ColumnDataType, TC.IsPrimaryKeyCol, TC.IsComputedCol, TC.IsIdentityCol\r\n\t\tFROM @TableColumns AS TC;    \r\n\tEND\r\n\t--$EndRegion: To Get All Columns in the SourceSchema.SourceTable\r\n\t----\r\n\t--$BeginRegion: Get Match Columns Either From Primary Key (or) Identity Key\r\n\t/*\r\n\t--Criteria: Get the PrimaryKey Columns for the Table\r\n\t--If PrimaryKey is not defined, Then Check For Identity Column for Condition Check.\r\n\t*/\r\n\tDECLARE @MatchColumns AS TABLE\r\n\t(\r\n\t\tColumnName VARCHAR(256) NULL\r\n\t);\r\n\tDELETE @MatchColumns WHERE 1 = 1;\r\n\t--\r\n\t----$BeginRegion: Get the PrimaryKey Columns if Exists\r\n\tBEGIN\r\n\t\tINSERT INTO @MatchColumns ( ColumnName )\r\n\t\tSELECT ColumnName FROM @TableColumns\r\n\t\tWHERE IsPrimaryKeyCol = 1\r\n\t\tORDER BY ColID ASC;\r\n\t\t--\r\n\tEND;\r\n\t----$EndRegion: Get the PrimaryKey Columns if Exists\r\n\t--\r\n\t----$BeginRegion: Get Identity Column If Primary Key Doesn't Exists\r\n\tIF NOT EXISTS (SELECT 1 FROM @MatchColumns)\r\n\tBEGIN\r\n\t\tINSERT INTO @MatchColumns ( ColumnName )\r\n\t\tSELECT ColumnName FROM @TableColumns\r\n\t\tWHERE IsIdentityCol = 1\r\n\t\tORDER BY ColID ASC;\r\n\t\t--\r\n\tEND;\r\n\t----$EndRegion: Get Identity Column If Primary Key Doesn't Exists\r\n\t--\r\n\t--$EndRegion: Get Match Columns Either From Primary Key (or) Identity Key\r\n\t----\r\n\t--$BeginRegion: @MergeON_ColumnList Coalesce String\r\n\tDECLARE @MergeON_ColumnList AS VARCHAR(MAX);\r\n\t--\r\n\tSELECT @MergeON_ColumnList = COALESCE(@MergeON_ColumnList + ' AND T.[' + ColumnName + '] = S.[' + ColumnName + ']', 'T.[' + ColumnName + '] = S.[' + ColumnName + ']')\r\n\tFROM @MatchColumns;\r\n\t----If Source Table Does Not Have Both PrimaryKey Columns and Identity Column, Then:\r\n\tIF (@MergeON_ColumnList IS NULL)\r\n\tBEGIN\r\n\t\tSET @MergeON_ColumnList = 'T.<TargetColumnName> = S.<SourceColumnName>';\r\n\tEND;\r\n\t--$EndRegion: @MergeON_ColumnList Coalesce String\r\n\t----\r\n\t--$BeginRegion: Creating UpdateUnMatchedColumnList and UpdateSetColumnList\r\n\tIF @IncludeUpdate = 1\r\n\tBEGIN\r\n\t\t----$BeginRegion: Coalesce UpdateUnMatchedColumnList\r\n\t    DECLARE @UpdateUnMatchedColumnList VARCHAR(MAX);\r\n\t\tSET @UpdateUnMatchedColumnList = NULL;\r\n\t\tSELECT @UpdateUnMatchedColumnList = COALESCE(@UpdateUnMatchedColumnList +  \r\n\t\t\tCASE\r\n\t\t\t\tWHEN ColumnDataType = 'xml' THEN ' OR ISNULL(CONVERT(NVARCHAR(MAX), T.[' + ColumnName + '])COLLATE DATABASE_DEFAULT, '''') != ISNULL(CONVERT(NVARCHAR(MAX), S.[' + ColumnName + '])COLLATE DATABASE_DEFAULT, '''')'\r\n\t\t\t\tWHEN ColumnDataType = 'varbinary' THEN ' OR ISNULL(T.[' + ColumnName + '], 0) != ISNULL(S.[' + ColumnName + '], 0)'\r\n\t\t\t\tELSE ' OR ISNULL(T.[' + ColumnName + '], '''') != ISNULL(S.[' + ColumnName + '], '''')' END, \r\n\t\t\tCASE\r\n\t\t\t\tWHEN ColumnDataType = 'xml' THEN 'ISNULL(CONVERT(NVARCHAR(MAX), T.[' + ColumnName + '])COLLATE DATABASE_DEFAULT, '''') != ISNULL(CONVERT(NVARCHAR(MAX), S.[' + ColumnName + '])COLLATE DATABASE_DEFAULT, '''')'\r\n\t\t\t\tWHEN ColumnDataType = 'varbinary' THEN 'ISNULL(T.[' + ColumnName + '], 0) != ISNULL(S.[' + ColumnName + '], 0)'\r\n\t\t\t\tELSE 'ISNULL(T.[' + ColumnName + '], '''') != ISNULL(S.[' + ColumnName + '], '''')' END)\r\n\t\tFROM @TableColumns\r\n\t\tWHERE ColumnName NOT IN ( SELECT ColumnName FROM @MatchColumns ) --Exclude PrimaryKey Columns and Identity Columns\r\n\t\t\tAND IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\t----$EndRegion: Coalesce UpdateUnMatchedColumnList\r\n\t\t--\r\n\t\t----$BeginRegion: Coalesce UpdateSetColumnList\r\n\t\tDECLARE @UpdateSetColumnList VARCHAR(MAX);\r\n\t\tSET @UpdateSetColumnList = NULL;\r\n\t\tSELECT @UpdateSetColumnList = COALESCE(@UpdateSetColumnList + \r\n\t\t\tCASE WHEN ColumnDataType = 'xml' THEN ', T.[' + ColumnName + '] = CONVERT(NVARCHAR(MAX), S.[' + ColumnName + '])COLLATE DATABASE_DEFAULT'\r\n\t\t\t\tELSE ', T.[' + ColumnName + '] = S.[' + ColumnName + ']' END,\r\n\t\t\tCASE WHEN ColumnDataType = 'xml' THEN 'T.[' + ColumnName + '] = CONVERT(NVARCHAR(MAX), S.[' + ColumnName + '])COLLATE DATABASE_DEFAULT'\r\n\t\t\t\tELSE 'T.[' + ColumnName + '] = S.[' + ColumnName + ']' END)\r\n\t\tFROM @TableColumns\r\n\t\tWHERE ColumnName NOT IN ( SELECT ColumnName FROM @MatchColumns ) --Exclude PrimaryKey Columns and Identity Columns\r\n\t\t\tAND IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\t----$EndRegion: Coalesce UpdateSetColumnList\r\n\tEND\r\n\t--$EndRegion: Creating UpdateUnMatchedColumnList and UpdateSetColumnList\r\n\t----\r\n\t--$BeginRegion: Creating InsertColumnList And InsertValueList String\r\n\tIF @IncludeInsert = 1\r\n\tBEGIN\r\n\t\t----$BeginRegion: Coalesce InsertColumnList\r\n\t\tDECLARE @InsertColumnList VARCHAR(MAX);\r\n\t\tSET @InsertColumnList = NULL;\r\n\t\tSELECT @InsertColumnList = COALESCE(@InsertColumnList + ', [' + ColumnName + ']', '[' + ColumnName + ']')\r\n\t\tFROM @TableColumns\r\n\t\tWHERE IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\t----$EndRegion: Coalesce InsertColumnList\r\n\t\t--\r\n\t\t----$BeginRegion: Coalesce InsertValueList\r\n\t\tDECLARE @InsertValueList VARCHAR(MAX);\r\n\t\tSET @InsertValueList = NULL;\r\n\t\tSELECT @InsertValueList = COALESCE(@InsertValueList + \r\n\t\t\tCASE WHEN ColumnDataType = 'xml' THEN ', CONVERT(NVARCHAR(MAX), S.[' + ColumnName + '])COLLATE DATABASE_DEFAULT' ELSE ', S.[' + ColumnName + ']' END,\r\n\t\t\tCASE WHEN ColumnDataType = 'xml' THEN 'CONVERT(NVARCHAR(MAX), S.[' + ColumnName + '])COLLATE DATABASE_DEFAULT' ELSE 'S.[' + ColumnName + ']' END)\r\n\t\tFROM @TableColumns\r\n\t\tWHERE IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\t----$EndRegion: Coalesce InsertValueList\r\n\tEND\r\n\t--$EndRegion: Creating InsertColumnList And InsertValueList String\r\n\t----\r\n\t/* Begin : Printing the Merge Statement ***********************************************************************************************/\r\n\tIF @SourceServer IS NOT NULL\r\n\t\tPRINT '--**Note: Make Sure \"' + @SourceServer + '\" is Configured as Linked Server with Data Read Access';\r\n\tPRINT 'USE ' + @TargetDatabase + ';' + CHAR(10) --\r\n\t\t+ 'GO';\r\n\t--\r\n\tEXEC ('IF EXISTS \r\n\t(\r\n\t\tSELECT 1\r\n\t\tFROM ' + @TargetDatabase + '.sys.identity_columns AS IC\r\n\t\tINNER JOIN ' + @TargetDatabase + '.sys.tables AS TBL ON TBL.object_id = IC.object_id\r\n\t\tINNER JOIN ' + @TargetDatabase + '.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id\r\n\t\tWHERE SCH.name = ''' + @TargetSchema + ''' AND TBL.name = ''' + @TargetTable + '''\r\n\t)\r\n\tBEGIN\r\n\t\tPRINT ''--''\r\n\t\tPRINT ''SET IDENTITY_INSERT [' + @TargetDatabase + '].[' + @TargetSchema+'].[' + @TargetTable + '] ON;''\r\n\tEND' );\r\n\t--\r\n\tPRINT '--';\r\n\t--\r\n\tPRINT N'BEGIN TRY' + CHAR(10) --\r\n\t\t+ N'\tBEGIN TRANSACTION;';\r\n\t--\r\n\tPRINT N'\tMERGE INTO ' + QUOTENAME(@TargetDatabase) + '.' + QUOTENAME(@TargetSchema) + '.' + QUOTENAME(@TargetTable) + ' as T --TargetTable' + CHAR(10) --\r\n\t\t+ N'\tUSING ' + ISNULL(@SourceServer + '.', '') + QUOTENAME(@SourceDatabase) + '.' + QUOTENAME(@SourceSchema) + '.' + QUOTENAME(@SourceTable) + ' as S --SourceTable' + CHAR(10) --\r\n\t\t+ N'\tON ' + @MergeON_ColumnList;\r\n\t--\r\n\tIF @IncludeUpdate = 1\r\n\tBEGIN\r\n\t\tPRINT N'\tWHEN MATCHED AND ' + @UpdateUnMatchedColumnList;\r\n\t\tPRINT N'\t\tTHEN UPDATE SET ' + @UpdateSetColumnList;\r\n\tEND;\r\n\t--\r\n\tIF @IncludeInsert = 1\r\n\tBEGIN\r\n\t\tPRINT N'\tWHEN NOT MATCHED BY TARGET ';\r\n\t\tPRINT N'\t\tTHEN INSERT (' + @InsertColumnList + ')';\r\n\t\tPRINT N'\t\t\t VALUES (' + @InsertValueList + ')';\r\n\tEND;\r\n\t--\r\n\tIF @IncludeDelete = 1\r\n\tBEGIN\r\n\t\tPRINT N'\tWHEN NOT MATCHED BY SOURCE ';\r\n\t\tPRINT N'\t\tTHEN DELETE';\r\n\tEND;\r\n\t--Merge Statement should be ended with SemiColumn \";\"\r\n\tPRINT N'\t;';\r\n\t--\r\n\tPRINT N'\tCOMMIT TRANSACTION;' + CHAR(10) --\r\n\t\t+ N'END TRY' + CHAR(10) --\r\n\t\t+ N'BEGIN CATCH' + CHAR(10) --\r\n\t\t+ N'\tSELECT ERROR_NUMBER() AS \"ErrorNumber\", ERROR_SEVERITY() AS \"ErrorSeverity\", ERROR_STATE() AS \"ErrorState\", ERROR_PROCEDURE() AS \"ErrorProcedure\", ERROR_MESSAGE() AS \"ErrorMessage\", ERROR_LINE() AS \"ErrorLine\";' + CHAR(10) --\r\n\t\t+ N'\tDECLARE @ErrorMSG NVARCHAR(4000) = N''Error: '' + ERROR_MESSAGE();' + CHAR(10) --\r\n\t\t+ N'\tRAISERROR(@ErrorMSG, 0, 0) WITH NOWAIT;' + CHAR(10) --\r\n\t\t+ N'\tRAISERROR(''Transaction was Rolled Back.'', 0, 0) WITH NOWAIT;' + CHAR(10) --\r\n\t\t+ N'\tROLLBACK TRANSACTION;' + CHAR(10) --\r\n\t\t+ N'END CATCH;';\r\n\t--\r\n\tEXEC ('IF EXISTS \r\n\t(\r\n\t\tSELECT 1\r\n\t\tFROM ' + @TargetDatabase + '.sys.identity_columns AS IC\r\n\t\tINNER JOIN ' + @TargetDatabase + '.sys.tables AS TBL ON TBL.object_id = IC.object_id\r\n\t\tINNER JOIN ' + @TargetDatabase + '.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id\r\n\t\tWHERE SCH.name = ''' + @TargetSchema + ''' AND TBL.name = ''' + @TargetTable + '''\r\n\t)\r\n\tBEGIN\r\n\t\tPRINT ''--''\r\n\t\tPRINT ''SET IDENTITY_INSERT [' + @TargetDatabase + '].[' + @TargetSchema + '].[' + @TargetTable + '] OFF;''\r\n\tEND' );\r\n\t--\r\n\t/* End : Printing the Merge Statement *************************************************************************************************/\r\n\t--\r\n\tSET NOCOUNT OFF;\r\n--\r\nEND;",
  "placeholders": [
    {
      "name": "SourceLinkedServer",
      "defaultValue": "DELL7548"
    },
    {
      "name": "SourceDatabase",
      "defaultValue": "AdventureWorks2019"
    },
    {
      "name": "TargetDatabase",
      "defaultValue": "AdventureWorksNew"
    },
    {
      "name": "SourceSchema",
      "defaultValue": "Sales"
    },
    {
      "name": "TargetSchema",
      "defaultValue": "Sales"
    },
    {
      "name": "SourceTable",
      "defaultValue": "SalesOrderHeader"
    },
    {
      "name": "TargetTable",
      "defaultValue": "SalesOrderHeader"
    }
  ]
}