{
  "id": "264cbb75-fb36-4a19-aa73-f63a0eada290",
  "prefix": "GenerateMergeStatement",
  "description": "Generating Merge Statement to Sync Data in Source Table and Destination Table",
  "body": "/* =============================================================================================================================================================\r\n-- Server\t\t: TARGET SERVER\r\n-- Database\t\t: master\r\n-- Script\t\t: Generating Merge Statement to Sync Data in Source Table and Destination Table.\r\n-- Note:\t**Source Server CAN be Local or Linked Server.\r\n--\t\t\t**But Target Server CANNOT be Linked Server (i.e., Merge Statement Cannot Write Data in Target If It is a Linked Server).\r\n--\t\t\tSo, We need to create a Merge Statement using linked Server (with Data Access) as Source for referencing the Data but not for inserting the Data.\r\n--\t\t\tAnd We Need to Execute the Query in the Subscriber Server or in the Target Server where exactly you need to Write(DML) to Table Data.\r\n-- Usage**\t\t: Execute in TARGET SERVER ONLY.\r\n============================================================================================================================================================= */\r\nUSE master;\r\nGO\r\n--\r\nSET ANSI_NULLS ON;\r\nGO\r\nSET QUOTED_IDENTIFIER ON;\r\nGO\r\n--\r\nDECLARE --\r\n\t@SourceServer AS VARCHAR(256) = '$SourceLinkedServer$', -- Source Can Be LinkedServer Where Data Can Be Read But Target Cannot Be LinkedServer.\r\n\t@SourceDatabase AS VARCHAR(256) = '$SourceDatabase$',\r\n\t@TargetDatabase AS VARCHAR(256) = '$TargetDatabase$',\r\n\t@SourceSchema AS VARCHAR(256) = '$SourceSchema$',\r\n\t@TargetSchema AS VARCHAR(256) = '$TargetSchema$',\r\n\t@SourceTable AS VARCHAR(256) = '$SourceTable$',\r\n\t@TargetTable AS VARCHAR(256) = '$TargetTable$';\r\n--\r\nDECLARE --To Include/Exclude Statements for Insert, Update, Delete\r\n\t@IncludeInsert INT = 1, -- 1 = Included (Default) | 0 = Excluded\r\n\t@IncludeUpdate INT = 1, -- 1 = Included (Default) | 0 = Excluded\r\n\t@IncludeDelete INT = 1; -- 1 = Included (Default) | 0 = Excluded\r\n--\r\nDECLARE @Debug BIT = 1;\t\t-- 1 = Print Debug | 0 = Excluded (Default)\r\n--AS\r\n/* ===== ** DO NOT CHANGE CODE BELOW FROM HERE ** =========================================================================================================== */\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\t-- Assumptions\r\n\t-- The names of the columns are the same in both tables.\r\n\t-- There should be PrimaryKey(PK can be Composite) => If Not PK, Identity Value should be Present.\r\n\tDECLARE @SQLstring AS NVARCHAR(MAX);\r\n\r\n\t--$BeginRegion: Source and Target Objects Check\r\n\tDECLARE @ReturnINT INT, @ReturnTXT VARCHAR(256);\r\n\t----$BeginRegion: Source Server Check\r\n\tIF LTRIM(RTRIM(@SourceServer)) = ''\r\n\t\tSET @SourceServer = NULL;\r\n\tIF @SourceServer IS NOT NULL\r\n\tBEGIN\r\n\t\tSET @SQLstring --\r\n\t\t\t= N'IF EXISTS (SELECT 1 FROM master.sys.servers WHERE name = ''' + @SourceServer + N''' AND is_linked = 1)' + CHAR(10) --\r\n\t\t\t+ N'\tIF EXISTS (SELECT 1 FROM master.sys.servers WHERE name = ''' + @SourceServer + N''' AND is_linked = 1 AND is_data_access_enabled = 1)' + CHAR(10) --\r\n\t\t\t+ N'\t\tSET @ReturnOUT1 = 0;' + CHAR(10) --\r\n\t\t\t+ N'\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Server Exists But Data Access Is Not Enabled..!''; END;' + CHAR(10) --\r\n\t\t\t+ N'ELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Server Does Not Exists..!''; END;';\r\n\t\t--PRINT @SQLstring\r\n\t\tEXECUTE sys.sp_executesql @CMD = @SQLstring, @PARAM = N'@ReturnOUT1 INT OUTPUT, @ReturnOUT2 VARCHAR(256) OUTPUT', @ReturnOUT1 = @ReturnINT OUTPUT, @ReturnOUT2 = @ReturnTXT OUTPUT;\r\n\t\tIF @ReturnINT = 1\r\n\t\tBEGIN\r\n\t\t\tSELECT @ReturnTXT AS \"ErrorMessage..!\";\r\n\t\t\tRAISERROR(@ReturnTXT, 16, 1) WITH NOWAIT;\r\n\t\t\tRETURN;\t    \r\n\t\tEND;\r\n\tEND;\r\n\t----$EndRegion: Source Server Check\r\n\t--\r\n\t----$BeginRegion: Source Object Check\r\n\tSET @SQLstring --\r\n\t\t= N'IF EXISTS (SELECT 1 FROM ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + N'master.sys.databases WHERE name = ''' + @SourceDatabase + N''')' + CHAR(10) --\r\n\t\t+ N'\tIF EXISTS (SELECT 1 FROM ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.schemas WHERE name = ''' + @SourceSchema + N''')' + CHAR(10) --\r\n\t\t+ N'\t\tIF EXISTS (SELECT 1 FROM ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.tables AS TBL INNER JOIN ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id WHERE SCH.name = ''' + @SourceSchema + N''' AND TBL.name = ''' + @SourceTable + N''')' + CHAR(10) --\r\n\t\t+ N'\t\t\tSET @ReturnOUT1 = 0;' + CHAR(10) --\r\n\t\t+ N'\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Database And Source Schema Exists But Source Table Does Not Exists..!''; END;' + CHAR(10) --\r\n\t\t+ N'\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Database Exists But Source Schema Does Not Exists..!''; END;' + CHAR(10) --\r\n\t\t+ N'ELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Source Database Does Not Exists..!''; END;';\r\n\t--PRINT @SQLstring;\r\n\tEXECUTE sys.sp_executesql @CMD = @SQLstring, @PARAM = N'@ReturnOUT1 INT OUTPUT, @ReturnOUT2 VARCHAR(256) OUTPUT', @ReturnOUT1 = @ReturnINT OUTPUT, @ReturnOUT2 = @ReturnTXT OUTPUT;\r\n\tIF @ReturnINT = 1\r\n\tBEGIN\r\n\t\tSELECT @ReturnTXT AS \"ErrorMessage..!\";\r\n\t\tRAISERROR(@ReturnTXT, 16, 1) WITH NOWAIT;\r\n\t\tRETURN;\r\n\tEND;\r\n\t----$EndRegion: Source Object Check\r\n\t--\r\n\t----$BeginRegion: Target Object Check\r\n\tSET @SQLstring --\r\n\t\t= N'IF EXISTS (SELECT 1 FROM sys.databases WHERE name = ''' + @TargetDatabase + N''')' + CHAR(10) --\r\n\t\t+ N'\tIF EXISTS (SELECT 1 FROM ' + @TargetDatabase + N'.sys.schemas WHERE name = ''' + @TargetSchema + N''')' + CHAR(10) --\r\n\t\t+ N'\t\tIF EXISTS (SELECT 1 FROM ' + @TargetDatabase + N'.sys.tables AS TBL INNER JOIN ' + @TargetDatabase + N'.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id WHERE SCH.name = ''' + @TargetSchema + N''' AND TBL.name = ''' + @TargetTable + N''')' + CHAR(10) --\r\n\t\t+ N'\t\t\tSET @ReturnOUT1 = 0;' + CHAR(10) --\r\n\t\t+ N'\t\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Target Database And Target Schema Exists But Target Table Does Not Exists..!''; END;' + CHAR(10) --\r\n\t\t+ N'\tELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Target Database Exists But Target Schema Does Not Exists..!''; END;' + CHAR(10) --\r\n\t\t+ N'ELSE BEGIN SET @ReturnOUT1 = 1; SET @ReturnOUT2 = ''Target Database Does Not Exists..!''; END;';\r\n\t--PRINT @SQLstring;\r\n\tEXECUTE sys.sp_executesql @CMD = @SQLstring, @PARAM = N'@ReturnOUT1 INT OUTPUT, @ReturnOUT2 VARCHAR(256) OUTPUT', @ReturnOUT1 = @ReturnINT OUTPUT, @ReturnOUT2 = @ReturnTXT OUTPUT;\r\n\tIF @ReturnINT = 1\r\n\tBEGIN\r\n\t\tSELECT @ReturnTXT AS \"ErrorMessage..!\";\r\n\t\tRAISERROR(@ReturnTXT, 16, 1) WITH NOWAIT;\r\n\t\tRETURN;\r\n\tEND;\r\n\t----$EndRegion: Target Object Check\r\n\t--$EndRegion: Source and Target Objects Check\r\n\t----\r\n\t--$BeginRegion: To Get All Columns in the SourceSchema.SourceTable\r\n\tDECLARE @TableColumns TABLE\r\n\t(\r\n\t\tColID INT NULL, --ORDINAL_POSITION\r\n\t\tColumnName VARCHAR(256) NULL,\r\n\t\tColumnDataType VARCHAR(64) NULL,\r\n\t\tIsPrimaryKeyCol BIT NULL,\r\n\t\tIsComputedCol BIT NULL,\r\n\t\tIsIdentityCol BIT NULL\r\n\t);\r\n\t--\r\n\tSET @SQLstring --\r\n\t\t= N'SELECT DISTINCT COL.column_id, COL.name, ISC.DATA_TYPE, ISNULL(PKC.Is_PK, 0), COL.is_computed, COL.is_identity' + CHAR(10) --\r\n\t\t+ N'FROM ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.columns AS COL' + CHAR(10) --\r\n\t\t+ N'INNER JOIN ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.tables AS TBL ON TBL.object_id = COL.object_id' + CHAR(10) --\r\n\t\t+ N'INNER JOIN ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id' + CHAR(10) --\r\n\t\t+ N'INNER JOIN ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.INFORMATION_SCHEMA.COLUMNS AS ISC ON ISC.TABLE_SCHEMA = SCH.name AND ISC.TABLE_NAME = TBL.name AND ISC.COLUMN_NAME = COL.name' + CHAR(10) --\r\n\t\t+ N'LEFT JOIN (' + CHAR(10) --\r\n\t\t+ N'\t\t\tSELECT IC.object_id, IC.column_id, 1 AS \"Is_PK\"' + CHAR(10) --\r\n\t\t+ N'\t\t\tFROM ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.index_columns AS IC' + CHAR(10) --\r\n\t\t+ N'\t\t\tINNER JOIN ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + @SourceDatabase + N'.sys.key_constraints AS KC ON IC.object_id = KC.parent_object_id AND IC.index_id = KC.unique_index_id AND KC.type = ''PK''' + CHAR(10) --\r\n\t\t+ N'\t\t  ) AS PKC ON PKC.column_id = COL.column_id AND PKC.object_id = COL.object_id' + CHAR(10) --\r\n\t\t+ N'WHERE SCH.name = ''' + @SourceSchema + N''' AND TBL.name = ''' + @SourceTable + N'''' + CHAR(10) --\r\n\t\t+ N'ORDER BY COL.column_id ASC;';\r\n\t\t--PRINT @SQLstring;\r\n\t--\r\n\tINSERT INTO @TableColumns\r\n\t(\r\n\t\tColID,\r\n\t\tColumnName,\r\n\t\tColumnDataType,\r\n\t\tIsPrimaryKeyCol,\r\n\t\tIsComputedCol,\r\n\t\tIsIdentityCol\r\n\t)\r\n\tEXEC sys.sp_executesql @statement = @SQLstring;\r\n\tIF @Debug = 1\r\n\tBEGIN\r\n\t\tSELECT ISNULL(@SourceServer, 'LocalServer') AS \"SourceServer\", @SourceDatabase AS \"SourceDatabase\", @SourceSchema AS \"SourceSchema\", @SourceTable AS \"SourceTable\",\r\n\t\t\t   TC.ColID, TC.ColumnName, TC.ColumnDataType, TC.IsPrimaryKeyCol, TC.IsComputedCol, TC.IsIdentityCol\r\n\t\tFROM @TableColumns AS TC;\r\n\tEND;\r\n\t--$EndRegion: To Get All Columns in the SourceSchema.SourceTable\r\n\t----\r\n\t----\r\n\t/* ===== ** PRINTING THE MERGE STATEMENT FOR THE TABLE ** =============================================================================================== */\r\n\t--$BeginRegion: /* Printing the Merge Statement ***************************************************************************************/\r\n\tIF @SourceServer IS NOT NULL\r\n\t\tPRINT N'--**Note: Make Sure \"' + @SourceServer + N'\" is Configured as Linked Server with Data Read Access';\r\n\t--\r\n\tPRINT N'USE [' + @TargetDatabase + N'];' + CHAR(10) --\r\n\t\t+ N'GO';\r\n\t--\r\n\t--$BeginRegion: Set Identity_Insert ON If Applicable\r\n\tEXEC (N'IF EXISTS \r\n\t(\r\n\t\tSELECT 1\r\n\t\tFROM [' + @TargetDatabase + N'].sys.identity_columns AS IC\r\n\t\tINNER JOIN [' + @TargetDatabase + N'].sys.tables AS TBL ON TBL.object_id = IC.object_id\r\n\t\tINNER JOIN [' + @TargetDatabase + N'].sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id\r\n\t\tWHERE SCH.name = ''' + @TargetSchema + N''' AND TBL.name = ''' + @TargetTable + N'''\r\n\t)\r\n\tBEGIN\r\n\t\tPRINT N''--''\r\n\t\tPRINT N''SET IDENTITY_INSERT [' + @TargetDatabase + N'].[' + @TargetSchema + N'].[' + @TargetTable + N'] ON;''\r\n\tEND' );\r\n\t--$EndRegion: Set Identity_Insert ON If Applicable\r\n\t--\r\n\tPRINT N'--';\r\n\t--\r\n\tPRINT N'BEGIN TRY' + CHAR(10) --\r\n\t\t+ N'\tBEGIN TRANSACTION;';\r\n\t--\r\n\tPRINT N'\tMERGE INTO ' + QUOTENAME(@TargetDatabase) + N'.' + QUOTENAME(@TargetSchema) + N'.' + QUOTENAME(@TargetTable) + N' as T --TargetTable';\r\n\tPRINT N'\tUSING ' + ISNULL(QUOTENAME(@SourceServer) + N'.', '') + QUOTENAME(@SourceDatabase) + N'.' + QUOTENAME(@SourceSchema) + N'.' + QUOTENAME(@SourceTable) + N' as S --SourceTable';\r\n\t--\r\n\t--$BeginRegion: Get Match Columns Either From Primary Key (or) Identity Key And Create @MergeON_ColumnList Coalesce String\r\n\t/*\r\n\t--Criteria: Get the PrimaryKey Columns(It can be Composite PK) for MergeON Condition Check. (1st Preference)\r\n\t--If PrimaryKey is not defined, Then Check For Identity Column for MergeON Condition Check. (2nd Preference)\r\n\t*/\r\n\tDECLARE @MatchColumns AS TABLE ( ColID INT NULL, ColumnName VARCHAR(256) NULL );\r\n\tDELETE @MatchColumns WHERE 1 = 1;\r\n\t--\r\n\t----$BeginRegion: Get the PrimaryKey Columns if Exists\r\n\tBEGIN\r\n\t\tINSERT INTO @MatchColumns ( ColID, ColumnName )\r\n\t\tSELECT ColID, ColumnName FROM @TableColumns\r\n\t\tWHERE IsPrimaryKeyCol = 1\r\n\t\tORDER BY ColID ASC;\r\n\t\t--\r\n\tEND;\r\n\t----$EndRegion: Get the PrimaryKey Columns if Exists\r\n\t--\r\n\t----$BeginRegion: Get Identity Column If Primary Key Doesn't Exists\r\n\tIF NOT EXISTS (SELECT 1 FROM @MatchColumns)\r\n\tBEGIN\r\n\t\tINSERT INTO @MatchColumns ( ColID, ColumnName )\r\n\t\tSELECT ColID, ColumnName FROM @TableColumns\r\n\t\tWHERE IsIdentityCol = 1\r\n\t\tORDER BY ColID ASC;\r\n\t\t--\r\n\tEND;\r\n\t----$EndRegion: Get Identity Column If Primary Key Doesn't Exists\r\n\t--\r\n\t----$BeginRegion: @MergeON_ColumnList Coalesce String\r\n\tDECLARE @MergeON_ColumnList AS VARCHAR(MAX);\r\n\t--\r\n\tSELECT @MergeON_ColumnList = COALESCE(@MergeON_ColumnList + N' AND T.[' + ColumnName + N'] = S.[' + ColumnName + N']', 'T.[' + ColumnName + N'] = S.[' + ColumnName + N']')\r\n\tFROM @MatchColumns\r\n\tORDER BY ColID ASC;\r\n\t------If Source Table Does Not Have Both PrimaryKey Columns and Identity Column, Then:\r\n\tIF (@MergeON_ColumnList IS NULL)\r\n\tBEGIN\r\n\t\tSET @MergeON_ColumnList = 'T.<TargetColumnName> = S.<SourceColumnName>';\r\n\tEND;\r\n\t----$EndRegion: @MergeON_ColumnList Coalesce String\r\n\tPRINT N'\tON ' + @MergeON_ColumnList;\r\n\t--\r\n\t--$EndRegion: Get Match Columns Either From Primary Key (or) Identity Key And Create @MergeON_ColumnList Coalesce String\r\n\t--\r\n\tIF @IncludeUpdate = 1\r\n\tBEGIN\r\n\t\t--$BeginRegion: Creating UpdateUnMatchedColumnList and UpdateSetColumnList\r\n\t\tDECLARE @UpdateUnMatchedColumns TABLE\r\n\t\t(\r\n\t\t\tColID INT NULL, --ORDINAL_POSITION\r\n\t\t\tColumnName VARCHAR(256) NULL,\r\n\t\t\tColumnDataType VARCHAR(64) NULL\r\n\t\t);\r\n\t\tINSERT INTO @UpdateUnMatchedColumns (ColID, ColumnName, ColumnDataType)\r\n\t\tSELECT ROW_NUMBER() OVER (ORDER BY ColID ASC) AS ColID,  ColumnName, ColumnDataType\r\n\t\tFROM @TableColumns\r\n\t\tWHERE ColumnName NOT IN ( SELECT ColumnName FROM @MatchColumns ) --Exclude PrimaryKey Columns and Identity Columns\r\n\t\tAND IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\t--\r\n\t\tDECLARE @Col_i INT, @Col_n INT;\r\n\t\tDECLARE @ColumnName VARCHAR(256) = '', @ColumnDataType varchar(64) = '';\r\n\t\tSELECT @Col_i = 1, @Col_n = MAX(ColID) FROM @UpdateUnMatchedColumns;\r\n\t\t--\r\n\t\t----$BeginRegion: Creating UpdateUnMatchedColumnList\r\n\t\tPRINT N'\tWHEN MATCHED';\r\n\t\tDECLARE @UpdateUnMatchedColumnList VARCHAR(MAX);\r\n\t\tSET @UpdateUnMatchedColumnList = NULL;\r\n\t\tSET @Col_i = 1; --Resetting @Col_i\r\n\t\tWHILE @Col_i <= @Col_n\r\n\t\tBEGIN\r\n\t\t    SELECT @ColumnName = ColumnName, @ColumnDataType = ColumnDataType FROM @UpdateUnMatchedColumns WHERE ColID = @Col_i;\t\t\t\r\n\t\t\t--\r\n\t\t\tSET @UpdateUnMatchedColumnList =  \r\n\t\t\t\tCASE\r\n\t\t\t\t\tWHEN @ColumnDataType = 'xml' THEN N'ISNULL(CONVERT(NVARCHAR(MAX), T.[' + @ColumnName + N'])COLLATE DATABASE_DEFAULT, '''') != ISNULL(CONVERT(NVARCHAR(MAX), S.[' + @ColumnName + N'])COLLATE DATABASE_DEFAULT, '''')'\r\n\t\t\t\t\tWHEN @ColumnDataType = 'varbinary' THEN N' ISNULL(T.[' + @ColumnName + N'], 0) != ISNULL(S.[' + @ColumnName + N'], 0)'\r\n\t\t\t\t\tELSE N'ISNULL(T.[' + @ColumnName + N'], '''') != ISNULL(S.[' + @ColumnName + N'], '''')' \r\n\t\t\t\tEND;\r\n\t\t\tPRINT CASE @Col_i WHEN 1 THEN N'\t\t\tAND ' + @UpdateUnMatchedColumnList ELSE N'\t\t\tOR  ' + @UpdateUnMatchedColumnList END;\r\n\t\t\t--\r\n\t\t\tSET @Col_i = @Col_i + 1;\r\n\t\tEND;\r\n\t\t----$EndRegion: Creating UpdateUnMatchedColumnList\r\n\t\t--\r\n\t\t----$BeginRegion: Creating UpdateSetColumnList\r\n\t\tPRINT N'\t\tTHEN UPDATE SET';\r\n\t\tDECLARE @UpdateSetColumnList VARCHAR(MAX);\r\n\t\tSET @UpdateSetColumnList = NULL;\r\n\t\tSET @Col_i = 1; --Resetting @Col_i\r\n\t\tWHILE @Col_i <= @Col_n\r\n\t\tBEGIN\r\n\t\t    SELECT @ColumnName = ColumnName, @ColumnDataType = ColumnDataType FROM @UpdateUnMatchedColumns WHERE ColID = @Col_i;\t\t\t\r\n\t\t\t--\r\n\t\t\tSET @UpdateSetColumnList =  \r\n\t\t\t\tCASE WHEN @ColumnDataType = 'xml' THEN N'T.[' + @ColumnName + N'] = CONVERT(NVARCHAR(MAX), S.[' + @ColumnName + N'])COLLATE DATABASE_DEFAULT'\r\n\t\t\t\t\tELSE N'T.[' + @ColumnName + N'] = S.[' + @ColumnName + N']' END;\r\n\t\t\tPRINT CASE WHEN @Col_i <> @Col_n THEN N'\t\t\t\t' + @UpdateSetColumnList + N',' ELSE N'\t\t\t\t' + @UpdateSetColumnList END;\r\n\t\t\t--\r\n\t\t\tSET @Col_i = @Col_i + 1;\r\n\t\tEND;\r\n\t\t----$EndRegion: Creating UpdateSetColumnList\r\n\t\t--$EndRegion: Creating UpdateUnMatchedColumnList and UpdateSetColumnList\r\n\tEND;\r\n\t--\r\n\tIF @IncludeInsert = 1\r\n\tBEGIN\r\n\t\t--$BeginRegion: Creating InsertColumnList And InsertValueList String\r\n\t\tPRINT N'\tWHEN NOT MATCHED BY TARGET';\r\n\t\t----$BeginRegion: Coalesce InsertColumnList\r\n\t\tDECLARE @InsertColumnList VARCHAR(MAX);\r\n\t\tSET @InsertColumnList = NULL;\r\n\t\tSELECT @InsertColumnList = COALESCE(@InsertColumnList + N', [' + ColumnName + N']', '[' + ColumnName + N']')\r\n\t\tFROM @TableColumns\r\n\t\tWHERE IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\tPRINT N'\t\tTHEN INSERT (' + @InsertColumnList + N')';\r\n\t\t----$EndRegion: Coalesce InsertColumnList\r\n\t\t--\r\n\t\t----$BeginRegion: Coalesce InsertValueList\r\n\t\tDECLARE @InsertValueList VARCHAR(MAX);\r\n\t\tSET @InsertValueList = NULL;\r\n\t\tSELECT @InsertValueList = COALESCE(@InsertValueList + \r\n\t\t\tCASE WHEN ColumnDataType = 'xml' THEN ', CONVERT(NVARCHAR(MAX), S.[' + ColumnName + N'])COLLATE DATABASE_DEFAULT' ELSE ', S.[' + ColumnName + N']' END,\r\n\t\t\tCASE WHEN ColumnDataType = 'xml' THEN 'CONVERT(NVARCHAR(MAX), S.[' + ColumnName + N'])COLLATE DATABASE_DEFAULT' ELSE 'S.[' + ColumnName + N']' END)\r\n\t\tFROM @TableColumns\r\n\t\tWHERE IsComputedCol <> 1 --Exclude Computed Columns\r\n\t\tORDER BY ColID ASC;\r\n\t\tPRINT N'\t\t\t VALUES (' + @InsertValueList + N')';\r\n\t\t----$EndRegion: Coalesce InsertValueList\r\n\t\t--$EndRegion: Creating InsertColumnList And InsertValueList String\r\n\tEND;\r\n\t--\r\n\tIF @IncludeDelete = 1\r\n\tBEGIN\r\n\t\t--$BeginRegion: Delete If Not Matched\r\n\t\tPRINT N'\tWHEN NOT MATCHED BY SOURCE ';\r\n\t\tPRINT N'\t\tTHEN DELETE';\r\n\t\t--$EndRegion: Delete If Not Matched\r\n\tEND;\r\n\t--Merge Statement should be ended with SemiColumn \";\"\r\n\tPRINT N'\t;';\r\n\t--\r\n\tPRINT N'\tCOMMIT TRANSACTION;' + CHAR(10) --\r\n\t\t+ N'END TRY' + CHAR(10) --\r\n\t\t+ N'BEGIN CATCH' + CHAR(10) --\r\n\t\t+ N'\tSELECT ERROR_NUMBER() AS \"ErrorNumber\", ERROR_SEVERITY() AS \"ErrorSeverity\", ERROR_STATE() AS \"ErrorState\", ERROR_PROCEDURE() AS \"ErrorProcedure\", ERROR_MESSAGE() AS \"ErrorMessage\", ERROR_LINE() AS \"ErrorLine\";' + CHAR(10) --\r\n\t\t+ N'\tDECLARE @ErrorMSG NVARCHAR(4000) = ''Error: '' + ERROR_MESSAGE();' + CHAR(10) --\r\n\t\t+ N'\tRAISERROR(@ErrorMSG, 0, 0) WITH NOWAIT;' + CHAR(10) --\r\n\t\t+ N'\tRAISERROR(''Transaction was Rolled Back.'', 0, 0) WITH NOWAIT;' + CHAR(10) --\r\n\t\t+ N'\tROLLBACK TRANSACTION;' + CHAR(10) --\r\n\t\t+ N'END CATCH;';\r\n\t--\r\n\t--$BeginRegion: Set Identity_Insert OFF If Applicable\r\n\tEXEC (N'IF EXISTS \r\n\t(\r\n\t\tSELECT 1\r\n\t\tFROM [' + @TargetDatabase + N'].sys.identity_columns AS IC\r\n\t\tINNER JOIN [' + @TargetDatabase + N'].sys.tables AS TBL ON TBL.object_id = IC.object_id\r\n\t\tINNER JOIN [' + @TargetDatabase + N'].sys.schemas AS SCH ON SCH.schema_id = TBL.schema_id\r\n\t\tWHERE SCH.name = ''' + @TargetSchema + N''' AND TBL.name = ''' + @TargetTable + N'''\r\n\t)\r\n\tBEGIN\r\n\t\tPRINT N''--''\r\n\t\tPRINT N''SET IDENTITY_INSERT [' + @TargetDatabase + N'].[' + @TargetSchema + N'].[' + @TargetTable + N'] OFF;''\r\n\tEND' );\r\n\t--$EndRegion: Set Identity_Insert OFF If Applicable\r\n\t--\r\n\t--$EndRegion: /* Printing the Merge Statement ***************************************************************************************/\r\n\t--\r\n\tPRINT 'GO' + CHAR(10);\r\n\tSET NOCOUNT OFF;\r\n--\r\nEND;\r\n",
  "placeholders": [
    {
      "name": "SourceLinkedServer",
      "defaultValue": "LinkedServerName"
    },
    {
      "name": "SourceDatabase",
      "defaultValue": "AdventureWorks2019"
    },
    {
      "name": "TargetDatabase",
      "defaultValue": "AdventureWorks2019Schema"
    },
    {
      "name": "SourceSchema",
      "defaultValue": "Sales"
    },
    {
      "name": "TargetSchema",
      "defaultValue": "Sales"
    },
    {
      "name": "SourceTable",
      "defaultValue": "SalesOrderHeader"
    },
    {
      "name": "TargetTable",
      "defaultValue": "SalesOrderHeader"
    }
  ]
}